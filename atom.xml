<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ryane&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="lijianchang.xyz/"/>
  <updated>2016-08-30T03:59:09.351Z</updated>
  <id>lijianchang.xyz/</id>
  
  <author>
    <name>Ryane Lee</name>
    <email>lijianchang@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java容器类源码-ArrayList的最全的源码分析</title>
    <link href="lijianchang.xyz/2016/08/30/Java%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%BA%90%E7%A0%81-ArrayList%E7%9A%84%E6%9C%80%E5%85%A8%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>lijianchang.xyz/2016/08/30/Java容器类源码-ArrayList的最全的源码分析/</id>
    <published>2016-08-30T01:50:04.617Z</published>
    <updated>2016-08-30T03:59:09.351Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是针对Java 1.8的源代码进行解析的，可能会和其他版本有所出入。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、继承和实现&quot;&gt;&lt;a href=&quot;#一、继承和实现&quot; class=&quot;headerlink&quot; title=&quot;一、继承和实现&quot;&gt;&lt;/a&gt;一、继承和实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;继承：&lt;/strong&gt;AbstractList&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;实现：&lt;/strong&gt;List&lt;e&gt;, RandomAccess, Cloneable, Serializable接口&lt;/e&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;源代码&quot;&gt;&lt;a href=&quot;#源代码&quot; class=&quot;headerlink&quot; title=&quot;源代码&quot;&gt;&lt;/a&gt;源代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;二、全局变量&quot;&gt;&lt;a href=&quot;#二、全局变量&quot; class=&quot;headerlink&quot; title=&quot;二、全局变量&quot;&gt;&lt;/a&gt;二、全局变量&lt;/h1&gt;&lt;h3 id=&quot;1-默认容量&quot;&gt;&lt;a href=&quot;#1-默认容量&quot; class=&quot;headerlink&quot; title=&quot;1. 默认容量&quot;&gt;&lt;/a&gt;1. 默认容量&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;private static final int DEFAULT_CAPACITY = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-空的对象数组&quot;&gt;&lt;a href=&quot;#2-空的对象数组&quot; class=&quot;headerlink&quot; title=&quot;2. 空的对象数组&quot;&gt;&lt;/a&gt;2. 空的对象数组&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;private static final Object[] EMPTY_ELEMENTDATA = {};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-默认的空数组&quot;&gt;&lt;a href=&quot;#3-默认的空数组&quot; class=&quot;headerlink&quot; title=&quot;3.默认的空数组&quot;&gt;&lt;/a&gt;3.默认的空数组&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// 无参构造函数创建的数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-存放数据的数组的缓存变量，不可序列化&quot;&gt;&lt;a href=&quot;#4-存放数据的数组的缓存变量，不可序列化&quot; class=&quot;headerlink&quot; title=&quot;4.存放数据的数组的缓存变量，不可序列化&quot;&gt;&lt;/a&gt;4.存放数据的数组的缓存变量，不可序列化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;transient Object[] elementData;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;5-数组的大小&quot;&gt;&lt;a href=&quot;#5-数组的大小&quot; class=&quot;headerlink&quot; title=&quot;5.数组的大小&quot;&gt;&lt;/a&gt;5.数组的大小&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;private int size;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;三、构造方法&quot;&gt;&lt;a href=&quot;#三、构造方法&quot; class=&quot;headerlink&quot; title=&quot;三、构造方法&quot;&gt;&lt;/a&gt;三、构造方法&lt;/h1&gt;&lt;h3 id=&quot;1-带有容量initialCapacity的构造方法&quot;&gt;&lt;a href=&quot;#1-带有容量initialCapacity的构造方法&quot; class=&quot;headerlink&quot; title=&quot;1.带有容量initialCapacity的构造方法&quot;&gt;&lt;/a&gt;1.带有容量initialCapacity的构造方法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayList(int initialCapacity) {
     // 如果初始化时ArrayList大小大于0
    if (initialCapacity &amp;gt; 0) {
          // new一个该大小的object数组赋给elementData
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) { // 如果大小为0
          // 将空数组赋给elementData
        this.elementData = EMPTY_ELEMENTDATA;
    } else { // 小于0
          // 则抛出IllegalArgumentException异常
        throw new IllegalArgumentException(&amp;quot;Illegal Capacity: &amp;quot;+
                                           initialCapacity);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-不带参数的构造方法&quot;&gt;&lt;a href=&quot;#2-不带参数的构造方法&quot; class=&quot;headerlink&quot; title=&quot;2.不带参数的构造方法&quot;&gt;&lt;/a&gt;2.不带参数的构造方法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayList() {
     // 直接将空数组赋给elementData  
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-带参数Collection的构造方法&quot;&gt;&lt;a href=&quot;#3-带参数Collection的构造方法&quot; class=&quot;headerlink&quot; title=&quot;3.带参数Collection的构造方法&quot;&gt;&lt;/a&gt;3.带参数Collection的构造方法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数c为一个Collection，Collection的实现类大概有以下几种常用类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List：元素可以重复的容器&lt;/li&gt;
&lt;li&gt;Set: 元素不可重复的容器&lt;/li&gt;
&lt;li&gt;Queue:结构是一个队列，先进先出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个构造方法的意思是，将一个Collection实现类的对象转换为一个ArrayList，但是c容器装的内容&lt;/p&gt;
&lt;p&gt;必须为ArrayList装的内容的子类。例如，将一个装了String内容的HashSet转换为装了String内容的&lt;/p&gt;
&lt;p&gt;ArrayList，使得ArrayList的大小和值数组都是HashSet的大小和值数组。具体实现如下代码，首先调&lt;/p&gt;
&lt;p&gt;用c(Collection的具体实现类)的toArray方法，具体大家可以看各个实现类的toArray方法，但是大&lt;/p&gt;
&lt;p&gt;概意思都是将c容器转换为object类型的数组，因为它们的返回值都是object[]。之于下面的两个判断&lt;/p&gt;
&lt;p&gt;是当得到的elementData的类名不是Object类名的时候或者是长度为0的时候才会执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;四、方法&quot;&gt;&lt;a href=&quot;#四、方法&quot; class=&quot;headerlink&quot; title=&quot;四、方法&quot;&gt;&lt;/a&gt;四、方法&lt;/h1&gt;&lt;h3 id=&quot;1-trimToSize&quot;&gt;&lt;a href=&quot;#1-trimToSize&quot; class=&quot;headerlink&quot; title=&quot;1.trimToSize()&quot;&gt;&lt;/a&gt;1.trimToSize()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;将ArrayList的容量设置为当前size的大小。首先需要明确一个概念，ArrayList的size就是ArrayList的元素个数，length是ArrayList申请的内容空间长度。ArrayList每次都会预申请多一点空间，以便添加元素的时候不需要每次都进行扩容操作，例如我们的元素个数是10个，它申请的内存空间必定会大于10，即length&amp;gt;size，而这个方法就是把ArrayList的内存空间设置为size，去除没有用到的null值空间。这也就是我们为什么每次在获取数据长度是都是调用list.size()而不是list.length()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;首先modCount是从类 java.util.AbstractList 继承的字段，这个字段主要是为了防止在多线程操作的情况下，List发生结构性的变化，什么意思呢？就是防止一个线程正在迭代，另外一个线程进行对List进行remove操作，这样当我们迭代到最后一个元素时，很明显此时List的最后一个元素为空，那么这时modCount就会告诉迭代器，让其抛出异常 ConcurrentModificationException。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果没有这一个变量，那么系统肯定会报异常ArrayIndexOutOfBoundsException，这样的异常显然不是应该出现的(这些运行时错误都是使用者的逻辑错误导致的，我们的JDK那么高端，不会出现使用错误，我们只抛出使用者造成的错误，而这个错误是设计者应该考虑的)，为了避免出现这样的异常，定义了检查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(引用自：郭无心，详情可以看他在知乎的回答：&lt;a href=&quot;https://www.zhihu.com/question/24086463/answer/64717159&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/24086463/answer/64717159&lt;/a&gt;)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void trimToSize() {
    modCount++;
     // 如果size小于length
    if (size &amp;lt; elementData.length) {
         // 重新将elementData设置大小为size
        elementData = (size == 0)
          ? EMPTY_ELEMENTDATA
          : Arrays.copyOf(elementData, size);
    }
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-size&quot;&gt;&lt;a href=&quot;#2-size&quot; class=&quot;headerlink&quot; title=&quot;2.size()&quot;&gt;&lt;/a&gt;2.size()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;返回ArrayList的大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;直接返回size&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public int size() {
    return size;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-isEmpty&quot;&gt;&lt;a href=&quot;#3-isEmpty&quot; class=&quot;headerlink&quot; title=&quot;3.isEmpty()&quot;&gt;&lt;/a&gt;3.isEmpty()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;返回是否为空&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释： &lt;/strong&gt;直接返回判断size==0 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean isEmpty() {
    return size == 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-indexOf-Object-o&quot;&gt;&lt;a href=&quot;#4-indexOf-Object-o&quot; class=&quot;headerlink&quot; title=&quot;4.indexOf(Object o)&quot;&gt;&lt;/a&gt;4.indexOf(Object o)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;对象o在ArrayList中的下标位置，如果存在返回位置i，不存在返回-1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;遍历ArrayList的大小，比较o和容器内的元素，若相等，则返回位置i，若遍历完都不相等，返回-1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i &amp;lt; size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i &amp;lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;5-contains-Object-o&quot;&gt;&lt;a href=&quot;#5-contains-Object-o&quot; class=&quot;headerlink&quot; title=&quot;5.contains(Object o)&quot;&gt;&lt;/a&gt;5.contains(Object o)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;是否包含对象o&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;调用indexOf()方法得到下标，存在则下标&amp;gt;=0，不存在为-1，即只要比较下标和0的大小即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean contains(Object o) {
    return indexOf(o) &amp;gt;= 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;6-lastIndexOf-Object-o&quot;&gt;&lt;a href=&quot;#6-lastIndexOf-Object-o&quot; class=&quot;headerlink&quot; title=&quot;6.lastIndexOf(Object o)&quot;&gt;&lt;/a&gt;6.lastIndexOf(Object o)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;返回容器内出现o的最后一个位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;从后向前遍历，得到第一个出现对象o的位置，不存在则返回-1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public int lastIndexOf(Object o) {
    if (o == null) {
        for (int i = size-1; i &amp;gt;= 0; i--)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = size-1; i &amp;gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;7-clone&quot;&gt;&lt;a href=&quot;#7-clone&quot; class=&quot;headerlink&quot; title=&quot;7.clone()&quot;&gt;&lt;/a&gt;7.clone()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;返回此 ArrayList 实例的浅表副本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Object clone() {
    try {
         // 调用父类(翻看源码可见是Object类)的clone方法得到一个ArrayList副本
        ArrayList&amp;lt;?&amp;gt; v = (ArrayList&amp;lt;?&amp;gt;) super.clone();
         // 调用Arrays类的copyOf，将ArrayList的elementData数组赋值给副本的elementData数组
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = 0;
         // 返回副本v
        return v;
    } catch (CloneNotSupportedException e) {
        throw new InternalError(e);
    }
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;8-toArray&quot;&gt;&lt;a href=&quot;#8-toArray&quot; class=&quot;headerlink&quot; title=&quot;8.toArray()&quot;&gt;&lt;/a&gt;8.toArray()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;ArrayList 实例转换为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;直接调用Arrays类的copyOf。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;9-toArray-T-a&quot;&gt;&lt;a href=&quot;#9-toArray-T-a&quot; class=&quot;headerlink&quot; title=&quot;9.toArray(T[] a)&quot;&gt;&lt;/a&gt;9.toArray(T[] a)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;将ArrayList里面的元素赋值到一个数组中去&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;如果a的长度小于ArrayList的长度，直接调用Arrays类的copyOf，返回一个比a数组长度要大的新数组，里面元素就是ArrayList里面的元素；如果a的长度比ArrayList的长度大，那么就调用System.arraycopy，将ArrayList的elementData数组赋值到a数组，然后把a数组的size位置赋值为空。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public &amp;lt;T&amp;gt; T[] toArray(T[] a) {
    if (a.length &amp;lt; size)
        // Make a new array of a&amp;apos;s runtime type, but my contents:
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &amp;gt; size)
        a[size] = null;
    return a;
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;10-rangeCheck-int-index&quot;&gt;&lt;a href=&quot;#10-rangeCheck-int-index&quot; class=&quot;headerlink&quot; title=&quot;10.rangeCheck(int index)&quot;&gt;&lt;/a&gt;10.rangeCheck(int index)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;测试index是否越界&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void rangeCheck(int index) {
     // 如果下标超过ArrayList的数组长度
    if (index &amp;gt;= size)
         // 抛出IndexOutOfBoundsException异常
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;11-get-int-index&quot;&gt;&lt;a href=&quot;#11-get-int-index&quot; class=&quot;headerlink&quot; title=&quot;11.get(int index)&quot;&gt;&lt;/a&gt;11.get(int index)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;获取index位置的元素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;先检查是否越界，然后返回ArrayList的elementData数组index位置的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public E get(int index) {
     // 检查是否越界
    rangeCheck(index);
     // 返回ArrayList的elementData数组index位置的元素
    return elementData(index);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;12-set-int-index-E-element&quot;&gt;&lt;a href=&quot;#12-set-int-index-E-element&quot; class=&quot;headerlink&quot; title=&quot;12.set(int index, E element)&quot;&gt;&lt;/a&gt;12.set(int index, E element)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;设置index位置的元素值了element，返回该位置的之前的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public E set(int index, E element) {
     // 检查是否越界  
    rangeCheck(index);
     // 调用elementData(index)获取到当前位置的值
    E oldValue = elementData(index);
     // 将element赋值到ArrayList的elementData数组的第index位置
    elementData[index] = element;
    return oldValue;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;13-ensureCapacityInternal-int-minCapacity&quot;&gt;&lt;a href=&quot;#13-ensureCapacityInternal-int-minCapacity&quot; class=&quot;headerlink&quot; title=&quot;13.ensureCapacityInternal(int minCapacity)&quot;&gt;&lt;/a&gt;13.ensureCapacityInternal(int minCapacity)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;得到最小扩容量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
         // 获取默认的容量和传入参数的较大值
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;14-ensureExplicitCapacity-int-minCapacity&quot;&gt;&lt;a href=&quot;#14-ensureExplicitCapacity-int-minCapacity&quot; class=&quot;headerlink&quot; title=&quot;14.ensureExplicitCapacity(int minCapacity)&quot;&gt;&lt;/a&gt;14.ensureExplicitCapacity(int minCapacity)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;判断是否需要扩容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // 如果最小需要空间比elementData的内存空间要大，则需要扩容
    if (minCapacity - elementData.length &amp;gt; 0)
        grow(minCapacity);
} 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;15-grow-方法&quot;&gt;&lt;a href=&quot;#15-grow-方法&quot; class=&quot;headerlink&quot; title=&quot;15.grow()方法&quot;&gt;&lt;/a&gt;15.grow()方法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;帮助ArrayList动态扩容的核心方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MAX_VALUE为231-1，MAX_ARRAY_SIZE 就是获取Java中int的最大限制，以防止越界  
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private void grow(int minCapacity) {
    // 获取到ArrayList中elementData数组的内存空间长度
    int oldCapacity = elementData.length;
    // 扩容至原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    // 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 
    // 不够就将数组长度设置为需要的长度
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    // 判断有没超过最大限制
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间
    // 并将elementData的数据复制到新的内存空间
    elementData = Arrays.copyOf(elementData, newCapacity);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;16-add-E-e&quot;&gt;&lt;a href=&quot;#16-add-E-e&quot; class=&quot;headerlink&quot; title=&quot;16.add(E e)&quot;&gt;&lt;/a&gt;16.add(E e)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;添加元素e&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
     // 扩容
    ensureCapacityInternal(size + 1);  
    // 将e赋值给elementData的size+1的位置。
    elementData[size++] = e;
    return true;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;17-add-int-index-E-element&quot;&gt;&lt;a href=&quot;#17-add-int-index-E-element&quot; class=&quot;headerlink&quot; title=&quot;17.add(int index, E element)&quot;&gt;&lt;/a&gt;17.add(int index, E element)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;在ArrayList的index位置，添加元素element&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void add(int index, E element) {
    // 判断index是否越界  
    rangeCheckForAdd(index);
     // 扩容
    ensureCapacityInternal(size + 1);  
     // 将elementData从index位置开始，复制到elementData的index+1开始的连续空间
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
     // 在elementData的index位置赋值element
    elementData[index] = element;
     // ArrayList的大小加一  
    size++;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;18-remove-int-index&quot;&gt;&lt;a href=&quot;#18-remove-int-index&quot; class=&quot;headerlink&quot; title=&quot;18.remove(int index)&quot;&gt;&lt;/a&gt;18.remove(int index)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;在ArrayList的移除index位置的元素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public E remove(int index) {
     // 判断是否越界  
    rangeCheck(index);
    modCount++;
     // 读取旧值  
    E oldValue = elementData(index);
     // 获取index位置开始到最后一个位置的个数
    int numMoved = size - index - 1;
    if (numMoved &amp;gt; 0)
         // 将elementData数组index+1位置开始拷贝到elementData从index开始的空间
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
     // 使size-1 ，设置elementData的size位置为空，让GC来清理内存空间
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;19-remove-Object-o&quot;&gt;&lt;a href=&quot;#19-remove-Object-o&quot; class=&quot;headerlink&quot; title=&quot;19.remove(Object o)&quot;&gt;&lt;/a&gt;19.remove(Object o)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;在ArrayList的移除对象为O的元素，跟indexOf方法思想基本一致&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &amp;lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &amp;lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;20-clear&quot;&gt;&lt;a href=&quot;#20-clear&quot; class=&quot;headerlink&quot; title=&quot;20.clear()&quot;&gt;&lt;/a&gt;20.clear()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;设置全部元素为null值，并设置size为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;可见clear操作并不是从空间内删除，只是设置为null值，等待垃圾回收机制来回收而已，把size设置为0，以便我们不会浏览到null值的内存空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void clear() {
    modCount++;
    // clear to let GC do its work
    for (int i = 0; i &amp;lt; size; i++)
        elementData[i] = null;
    size = 0;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;21-addAll-Collection-lt-extends-E-gt-c&quot;&gt;&lt;a href=&quot;#21-addAll-Collection-lt-extends-E-gt-c&quot; class=&quot;headerlink&quot; title=&quot;21.addAll(Collection&amp;lt;? extends E&amp;gt; c)&quot;&gt;&lt;/a&gt;21.addAll(Collection&amp;lt;? extends E&amp;gt; c)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;将Collection c的全部元素添加到ArrayList中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
     // 将c转换为数组a
    Object[] a = c.toArray();
     // 获取a占的内存空间长度赋值给numNew
    int numNew = a.length;
     // 扩容至size + numNew
    ensureCapacityInternal(size + numNew);  // Increments modCount
     // 将a的第0位开始拷贝至elementData的size位开始，拷贝长度为numNew
    System.arraycopy(a, 0, elementData, size, numNew);
     // 将size增加numNew  
    size += numNew;
     // 如果c为空，返回false，c不为空，返回true
    return numNew != 0;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;22-addAll-int-index-Collection-lt-extends-E-gt-c&quot;&gt;&lt;a href=&quot;#22-addAll-int-index-Collection-lt-extends-E-gt-c&quot; class=&quot;headerlink&quot; title=&quot;22.addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)&quot;&gt;&lt;/a&gt;22.addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;从第index位开始，将c全部拷贝到ArrayList&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
     // 判断index大于size或者是小于0,如果是，则抛出IndexOutOfBoundsException异常
    rangeCheckForAdd(index);
     // 将c转换为数组a
    Object[] a = c.toArray();
    int numNew = a.length;
     // 扩容至size + numNew
    ensureCapacityInternal(size + numNew);  // Increments modCount
      // 获取需要添加的个数
    int numMoved = size - index;
    if (numMoved &amp;gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                         numMoved);
    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;24-batchRemove-Collection-lt-gt-c-boolean-complement&quot;&gt;&lt;a href=&quot;#24-batchRemove-Collection-lt-gt-c-boolean-complement&quot; class=&quot;headerlink&quot; title=&quot;24.batchRemove(Collection&amp;lt;?&amp;gt; c, boolean complement)&quot;&gt;&lt;/a&gt;24.batchRemove(Collection&amp;lt;?&amp;gt; c, boolean complement)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;根据complement值，将ArrayList中包含c中元素的元素删除或者保留&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private boolean batchRemove(Collection&amp;lt;?&amp;gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
     // 定义一个w，一个r，两个同时右移   
    int r = 0, w = 0;
    boolean modified = false;
    try {
         // r先右移
        for (; r &amp;lt; size; r++)
              // 如果c中不包含elementData[r]这个元素
            if (c.contains(elementData[r]) == complement)
                  // 则直接将r位置的元素赋值给w位置的元素，w自增
                elementData[w++] = elementData[r];
    } finally {
        // 防止抛出异常导致上面r的右移过程没完成
        if (r != size) {
              // 将r未右移完成的位置的元素赋值给w右边位置的元素
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
              // 修改w值增加size-r
            w += size - r;
        }
        if (w != size) {
            // 如果有被覆盖掉的元素，则将w后面的元素都赋值为null
            for (int i = w; i &amp;lt; size; i++)
                elementData[i] = null;
            modCount += size - w;
              // 修改size为w
            size = w;
            modified = true;
        }
    }
    return modified;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;25-removeAll-Collection-lt-gt-c&quot;&gt;&lt;a href=&quot;#25-removeAll-Collection-lt-gt-c&quot; class=&quot;headerlink&quot; title=&quot;25.removeAll(Collection&amp;lt;?&amp;gt; c)&quot;&gt;&lt;/a&gt;25.removeAll(Collection&amp;lt;?&amp;gt; c)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;ArrayList移除c中的所有元素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean removeAll(Collection&amp;lt;?&amp;gt; c) {
     // 如果c为空，则抛出空指针异常
    Objects.requireNonNull(c);
     // 调用batchRemove移除c中的元素
    return batchRemove(c, false);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;26-retainAll-Collection-lt-gt-c&quot;&gt;&lt;a href=&quot;#26-retainAll-Collection-lt-gt-c&quot; class=&quot;headerlink&quot; title=&quot;26.retainAll(Collection&amp;lt;?&amp;gt; c)&quot;&gt;&lt;/a&gt;26.retainAll(Collection&amp;lt;?&amp;gt; c)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;和removeAll相反，仅保留c中所有的元素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean retainAll(Collection&amp;lt;?&amp;gt; c) {
    Objects.requireNonNull(c);
     // 调用batchRemove保留c中的元素
    return batchRemove(c, true);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;27-iterator&quot;&gt;&lt;a href=&quot;#27-iterator&quot; class=&quot;headerlink&quot; title=&quot;27.iterator()&quot;&gt;&lt;/a&gt;27.iterator()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;返回一个Iterator对象，Itr为ArrayList的一个内部类，其实现了Iterator&lt;e&gt;接口&lt;/e&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Iterator&amp;lt;E&amp;gt; iterator() {
    return new Itr();
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;28-listIterator&quot;&gt;&lt;a href=&quot;#28-listIterator&quot; class=&quot;headerlink&quot; title=&quot;28.listIterator()&quot;&gt;&lt;/a&gt;28.listIterator()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;返回一个ListIterator对象，ListItr为ArrayList的一个内部类，其实现了ListIterator&lt;e&gt;  接口&lt;/e&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ListIterator&amp;lt;E&amp;gt; listIterator() {
    return new ListItr(0);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;29-listIterator-int-index&quot;&gt;&lt;a href=&quot;#29-listIterator-int-index&quot; class=&quot;headerlink&quot; title=&quot;29.listIterator(int index)&quot;&gt;&lt;/a&gt;29.listIterator(int index)&lt;/h3&gt;&lt;p&gt;说明：返回一个从index开始的ListIterator对象&lt;/p&gt;
&lt;p&gt;源码解释：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ListIterator&amp;lt;E&amp;gt; listIterator(int index) {
    if (index &amp;lt; 0 || index &amp;gt; size)
        throw new IndexOutOfBoundsException(&amp;quot;Index: &amp;quot;+index);
    return new ListItr(index);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;30-subList-int-fromIndex-int-toIndex&quot;&gt;&lt;a href=&quot;#30-subList-int-fromIndex-int-toIndex&quot; class=&quot;headerlink&quot; title=&quot;30.subList(int fromIndex, int toIndex)&quot;&gt;&lt;/a&gt;30.subList(int fromIndex, int toIndex)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;根据两个参数，获取到一个子序列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex) {
     // 检查异常
    subListRangeCheck(fromIndex, toIndex, size);
     // 调用SubList类的构造方法
    return new SubList(this, 0, fromIndex, toIndex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;五、内部类&quot;&gt;&lt;a href=&quot;#五、内部类&quot; class=&quot;headerlink&quot; title=&quot;五、内部类&quot;&gt;&lt;/a&gt;五、内部类&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;(1)private class Itr implements Iterator&amp;lt;E&amp;gt;
(2)private class ListItr extends Itr implements ListIterator&amp;lt;E&amp;gt;
(3)private class SubList extends AbstractList&amp;lt;E&amp;gt; implements RandomAccess
(4)static final class ArrayListSpliterator&amp;lt;E&amp;gt; implements Spliterator&amp;lt;E&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayList有四个内部类，&lt;/p&gt;
&lt;p&gt;其中的Itr是实现了Iterator接口，同时重写了里面的hasNext()，next()，remove()等方法；&lt;/p&gt;
&lt;p&gt;其中的ListItr继承Itr，实现了ListIterator接口，同时重写了hasPrevious()，nextIndex()，&lt;br&gt;previousIndex()，previous()，set(E e)，add(E e)等方法，所以这也可以看出了Iterator和ListIterator的区别，就是ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。具体可以参考&lt;a href=&quot;http://blog.csdn.net/a597926661/article/details/7679765。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/a597926661/article/details/7679765。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中的SubList继承AbstractList，实现了RandmAccess接口，类内部实现了对子序列的增删改查等方法，但它同时也充分利用了内部类的优点，就是共享ArrayList的全局变量，例如检查器变量modCount，数组elementData等，所以SubList进行的增删改查操作都是对ArrayList的数组进行的，并没有创建新的数组。&lt;/p&gt;
&lt;p&gt;最后一个比较个人比较少接触，大家需要自行度娘。&lt;/p&gt;
&lt;h1 id=&quot;End&quot;&gt;&lt;a href=&quot;#End&quot; class=&quot;headerlink&quot; title=&quot;End&quot;&gt;&lt;/a&gt;End&lt;/h1&gt;&lt;p&gt;笔者技术真的是一般般，写这个为了加深理解的同时给害怕看源代码的朋友一点鼓励，所以笔者在写的过程中有查阅很多资料来努力减少错误，但是如有错漏之处，希望大神们指出，我会第一时间修改，以免误人子弟，也希望和笔者一样基础不够好的朋友不要畏惧看源码，源码看起来并不会很难，而且多看源代码会对Java更深刻的理解。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是针对Java 1.8的源代码进行解析的，可能会和其他版本有所出入。&lt;/p&gt;
    
    </summary>
    
      <category term="Java源码" scheme="lijianchang.xyz/categories/Java%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="ArrayList" scheme="lijianchang.xyz/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>Android学习-创建圆角的DialogActivity</title>
    <link href="lijianchang.xyz/2016/08/30/Android%E5%AD%A6%E4%B9%A0-%E5%88%9B%E5%BB%BA%E5%9C%86%E8%A7%92%E7%9A%84DialogActivity/"/>
    <id>lijianchang.xyz/2016/08/30/Android学习-创建圆角的DialogActivity/</id>
    <published>2016-08-30T01:49:47.741Z</published>
    <updated>2016-08-30T03:52:34.968Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在安卓开发中我们多多少少都会使用到DialogActivity，但是系统自带的效果往往不尽如人意，一般都是下面这种效果，所以我们在使用时都会很蛋疼，最近在做项目需要用到圆角的DialogActivity，所以就参考网上资料，做了一个自己风格的圆角DialogActivit。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post_MakeDialogActivitydefault.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;示例图&quot;&gt;&lt;a href=&quot;#示例图&quot; class=&quot;headerlink&quot; title=&quot;示例图&quot;&gt;&lt;/a&gt;示例图&lt;/h2&gt;&lt;p&gt;示例图如下，是不是很有苹果风呢？其实在这个基础上大家可以定制成自己风格的DialogActivity&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post_MakeDialogActivitychange.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h2&gt;&lt;p&gt;1.首先设置DialogActivity最外层的的layout背景为一个自定义背景，自定义背景如下:&lt;/p&gt;
&lt;p&gt;dialog_theme.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;shape xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; &amp;gt;

    &amp;lt;!-- 填充颜色 --&amp;gt;
    &amp;lt;solid android:color=&amp;quot;#ffffffff&amp;quot; /&amp;gt;

    &amp;lt;!-- 边框宽度 --&amp;gt;
    &amp;lt;!-- &amp;lt;stroke android:width=&amp;quot;3dp&amp;quot; /&amp;gt; --&amp;gt;


    &amp;lt;!-- 圆角半径 --&amp;gt;
    &amp;lt;corners android:radius=&amp;quot;10dp&amp;quot; /&amp;gt;

    &amp;lt;!-- 内边距 --&amp;gt;
    &amp;lt;padding
        android:bottom=&amp;quot;13dp&amp;quot;
        android:left=&amp;quot;13dp&amp;quot;
        android:right=&amp;quot;13dp&amp;quot;
        android:top=&amp;quot;13dp&amp;quot; /&amp;gt;

&amp;lt;/shape&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.然后自定义Activity的style为如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style name=&amp;quot;DialogTheme&amp;quot; parent=&amp;quot;@android:style/Theme.Dialog&amp;quot;&amp;gt;

    &amp;lt;!-- 边框 --&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowFrame&amp;quot;&amp;gt;@null&amp;lt;/item&amp;gt;
    &amp;lt;!-- 是否浮现在activity之上 --&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowIsFloating&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt;
    &amp;lt;!-- 半透明 --&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowIsTranslucent&amp;quot;&amp;gt;false&amp;lt;/item&amp;gt;
    &amp;lt;!-- 无标题 --&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowNoTitle&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt;
    &amp;lt;!-- 背景透明 --&amp;gt;
    &amp;lt;item name=&amp;quot;android:windowBackground&amp;quot;&amp;gt;@android:color/transparent&amp;lt;/item&amp;gt;
    &amp;lt;!-- 模糊 --&amp;gt;
    &amp;lt;item name=&amp;quot;android:backgroundDimEnabled&amp;quot;&amp;gt;false&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h2&gt;&lt;p&gt;1.Demo效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post_MakeDialogActivitytest.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.github地址&lt;br&gt;&lt;a href=&quot;https://github.com/ryanlijianchang/DialogActivityDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ryanlijianchang/DialogActivityDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.下载地址&lt;br&gt;&lt;a href=&quot;http://download.csdn.net/detail/ljcitworld/9510717&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.csdn.net/detail/ljcitworld/9510717&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在安卓开发中我们多多少少都会使用到DialogActivity，但是系统自带的效果往往不尽如人意，一般都是下面这种效果，所以我们在使用时都会很蛋疼，最近在做项目需要用到圆角的DialogActivity，所以就参考网上资料，做了一个自己风格的圆角DialogActivit。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post_MakeDialogActivitydefault.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android学习" scheme="lijianchang.xyz/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DialogActivity" scheme="lijianchang.xyz/tags/DialogActivity/"/>
    
  </entry>
  
  <entry>
    <title>Android学习-使用Async-Http实现图片压缩并上传功能</title>
    <link href="lijianchang.xyz/2016/08/30/Android%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8Async-Http%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD/"/>
    <id>lijianchang.xyz/2016/08/30/Android学习-使用Async-Http实现图片压缩并上传功能/</id>
    <published>2016-08-30T01:49:43.160Z</published>
    <updated>2016-08-30T03:52:04.557Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;(转载请注明出处，谢谢！)&lt;/p&gt;
&lt;p&gt;最近在做一个小项目，项目中要实现上传图片到服务器，而这个例子是实现图片的尺寸压缩，将获取到的压缩图片转为流，然后使用Async-Http开源框架实现图片流的上传，然后在服务器端将流写入本地。&lt;/p&gt;
&lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-UpLoadPhoto3.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;安卓端&lt;/center&gt;

&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;center&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-UpLoadPhoto2.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;服务器端&lt;/center&gt;

&lt;h2 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;headerlink&quot; title=&quot;解决&quot;&gt;&lt;/a&gt;解决&lt;/h2&gt;&lt;h3 id=&quot;安卓端&quot;&gt;&lt;a href=&quot;#安卓端&quot; class=&quot;headerlink&quot; title=&quot;安卓端&quot;&gt;&lt;/a&gt;安卓端&lt;/h3&gt;&lt;p&gt;一、点击加载本地相册选择图片，然后加载到ImageView中去，并获取图片地址以供后面图片上传时使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //点击图片打开选择图片界面
photo.setOnClickListener(new OnClickListener() {

    @Override
    public void onClick(View v) {
        //使用Intent触发选择Action
        Intent intent = new Intent(Intent.ACTION_PICK, null);
        //打开系统提供的图片选择界面
        intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &amp;quot;image/*&amp;quot;);
        //传参以在返回本界面时触发加载图片的功能
        startActivityForResult(intent, 0x1);
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;//在选择图片后返回本界面调用此方法
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == 0x1 &amp;amp;&amp;amp; resultCode == RESULT_OK) {
        if (data != null) {

            ContentResolver resolver = getContentResolver();
            try {
                // 获取圖片URI
                Uri uri = data.getData();
                // 将URI转换为路径：
                String[] proj = { MediaStore.Images.Media.DATA };
                Cursor cursor = managedQuery(uri, proj, null, null, null);
                //  这个是获得用户选择的图片的索引值
                int column_index = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
                cursor.moveToFirst();
                // 最后根据索引值获取图片路径
                photoPath = cursor.getString(column_index);

                // 压缩成800*480
                bitmap = BitmapUtils.decodeSampledBitmapFromFd(photoPath, 480, 800);
                // 设置imageview显示图片
                photo.setImageBitmap(bitmap);
                // 设置textview显示路径
                path.setText(photoPath);
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;二、图片压缩。在我们需要上传图片时，我们不可能直接把原图上传到服务器，因为一般图片的大小都超过3，4M，所以我们在上传之前需要对图片进行压缩，我是把图片压缩放到了一个工具类，主要是对图片进行尺寸压缩。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BitmapUtils {

    private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 1;
        if (height &amp;gt; reqHeight || width &amp;gt; reqWidth) {
            //首先获取原图高度和宽度的一半
            final int halfHeight = height / 2;
            final int halfWidth = width / 2;
            //循环，如果halfHeight和halfWidth同时大于最小宽度和最小高度时，inSampleSize乘2，
            //最后得到的宽或者高都是最接近最小宽度或者最小高度的
            while ((halfHeight / inSampleSize) &amp;gt; reqHeight &amp;amp;&amp;amp; (halfWidth / inSampleSize) &amp;gt; reqWidth) {
                inSampleSize *= 2;
            }
        }
        return inSampleSize;
    }

    /**
     * 根据Resources压缩图片
     * 
     * @param res
     * @param resId
     * @param reqWidth
     * @param reqHeight
     * @return
     */
    public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeResource(res, resId, options);
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
        options.inJustDecodeBounds = false;
        Bitmap src = BitmapFactory.decodeResource(res, resId, options);
        return src;
    }

    /**
     * 根据地址压缩图片
     * 
     * @param pathName
     * @param reqWidth 最小宽度
     * @param reqHeight 最小高度
     * @return
     */
    public static Bitmap decodeSampledBitmapFromFd(String pathName, int reqWidth, int reqHeight) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        // 若要对图片进行压缩，必须先设置Option的inJustDecodeBounds为true才能进行Option的修改
        options.inJustDecodeBounds = true;
        // 第一次decodeFile是获取到options.outHeight和options.outWidth
        BitmapFactory.decodeFile(pathName, options);
        // options.inSampleSize是图片的压缩比，例如原来大小是100*100，options.inSampleSize为1，则不变，
        // options.inSampleSize为2，则压缩成50*50
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
        // 重新设置options.inJustDecodeBounds为false，不能修改option
        options.inJustDecodeBounds = false;
        // 根据options重新加载图片
        Bitmap src = BitmapFactory.decodeFile(pathName, options);
        return src;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;三、将Bitmap转为String，同时使用BASE64加密，使传输更加安全，这是我的工具类,里面再一次进行压缩是质量压缩，压缩比例是30%，具体自己调&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Utils {
    // 将bitmap转成string类型通过Base64
    public static String BitmapToString(Bitmap bitmap) {

        ByteArrayOutputStream bao = new ByteArrayOutputStream();
        // 将bitmap压缩成30%
        bitmap.compress(Bitmap.CompressFormat.JPEG, 30, bao);
        // 将bitmap转化为一个byte数组
        byte[] bs = bao.toByteArray();
        // 将byte数组用BASE64加密
        String photoStr = Base64.encodeToString(bs, Base64.DEFAULT);
        // 返回String
        return photoStr;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;四、通过Async-Http实现图片上传&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void upload(String url) {
    // 将bitmap转为string，并使用BASE64加密
    String photo = Utils.BitmapToString(bitmap);
    // 获取到图片的名字
    String name = photoPath.substring(photoPath.lastIndexOf(&amp;quot;/&amp;quot;)).substring(1);
    // new一个请求参数
    RequestParams params = new RequestParams();
    // 将图片和名字添加到参数中
    params.put(&amp;quot;photo&amp;quot;, photo);
    params.put(&amp;quot;name&amp;quot;, name);
    AsyncHttpClient client = new AsyncHttpClient();
    // 调用AsyncHttpClient的post方法
    client.post(url, params, new AsyncHttpResponseHandler() {

        @Override
        public void onFailure(int arg0, Header[] arg1, byte[] arg2, Throwable arg3) {
            Toast.makeText(getApplicationContext(), &amp;quot;上传失败!&amp;quot;, Toast.LENGTH_SHORT).show();
        }

        @Override
        public void onSuccess(int arg0, Header[] arg1, byte[] arg2) {
            Toast.makeText(getApplicationContext(), &amp;quot;上传成功!&amp;quot;, Toast.LENGTH_SHORT).show();
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;服务器端&quot;&gt;&lt;a href=&quot;#服务器端&quot; class=&quot;headerlink&quot; title=&quot;服务器端&quot;&gt;&lt;/a&gt;服务器端&lt;/h3&gt;&lt;p&gt;一、创建一个新的Servlet，在doget方法里面实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class UpLoadPhotoServlet extends HttpServlet {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
        response.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
        response.setContentType(&amp;quot;text/html&amp;quot;);
        // 获取文件名
        String name = request.getParameter(&amp;quot;name&amp;quot;);
        // 获取图片
        String photo = request.getParameter(&amp;quot;photo&amp;quot;);
        // 将传进来的图片的string格式进行处理
        byte[] bs = new BASE64Decoder().decodeBuffer(photo);
        // 写到E盘Img文件夹下的a.jpg文件。注：Img文件夹一定要存在
        FileOutputStream fos = new FileOutputStream(&amp;quot;E:/Img/&amp;quot; + name);
        fos.write(bs);
        fos.flush();
        fos.close();

        PrintWriter writer = response.getWriter();
        writer.print(&amp;quot;上传成功&amp;quot;);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Demo地址&quot;&gt;&lt;a href=&quot;#Demo地址&quot; class=&quot;headerlink&quot; title=&quot;Demo地址&quot;&gt;&lt;/a&gt;Demo地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/detail/ljcitworld/9548619&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.csdn.net/detail/ljcitworld/9548619&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;(转载请注明出处，谢谢！)&lt;/p&gt;
&lt;p&gt;最近在做一个小项目，项目中要实现上传图片到服务器，而这个例子是实现图片的尺寸压缩，将获取到的压缩图片转为流，然后使用Async-Http开源框架实现图片流的上传，然后在服务器端将流写入本地。&lt;/p&gt;
&lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-UpLoadPhoto3.png&quot; alt=&quot;&quot;&gt;&lt;/center&gt;&lt;br&gt;&lt;center&gt;安卓端&lt;/center&gt;
    
    </summary>
    
      <category term="Android学习" scheme="lijianchang.xyz/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Async-Http" scheme="lijianchang.xyz/tags/Async-Http/"/>
    
  </entry>
  
  <entry>
    <title>Android学习-手把手教学实现仿微信发带图片朋友圈的UI设计</title>
    <link href="lijianchang.xyz/2016/08/30/Android%E5%AD%A6%E4%B9%A0-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6%E5%AE%9E%E7%8E%B0%E4%BB%BF%E5%BE%AE%E4%BF%A1%E5%8F%91%E5%B8%A6%E5%9B%BE%E7%89%87%E6%9C%8B%E5%8F%8B%E5%9C%88%E7%9A%84UI%E8%AE%BE%E8%AE%A1/"/>
    <id>lijianchang.xyz/2016/08/30/Android学习-手把手教学实现仿微信发带图片朋友圈的UI设计/</id>
    <published>2016-08-30T01:49:38.466Z</published>
    <updated>2016-08-30T05:44:30.411Z</updated>
    
    <content type="html">&lt;h2 id=&quot;功能需求&quot;&gt;&lt;a href=&quot;#功能需求&quot; class=&quot;headerlink&quot; title=&quot;功能需求&quot;&gt;&lt;/a&gt;功能需求&lt;/h2&gt;&lt;p&gt;最近自己在开发一个社交APP，发送动态（类似朋友圈）是社交APP必备的一个功能，而自己在开发过程中也需要开发到这一个功能，但是在开发中遇到了一个问题，就是如何绘制一个类似朋友群那样动态添加图片，并加号随着自己的图片增加而后移这一个UI，而这篇小文就是教你如何制作一个仿朋友圈发带图朋友圈的UI设计。注意，这是UI设计，并不是实现图片上传功能。&lt;/p&gt;
&lt;p&gt;当然，如果你想知道如何实现图片上传到服务器，请看我的另一篇文章：&lt;a href=&quot;http://blog.csdn.net/ljcitworld/article/details/51670910&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android学习-使用Async-Http实现图片压缩并上传功能&lt;/a&gt;。个人水平有限，如有不足的地方，欢迎交流，勿喷。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;p&gt;按照惯例，先上效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-SendPhotoUI2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;困难&quot;&gt;&lt;a href=&quot;#困难&quot; class=&quot;headerlink&quot; title=&quot;困难&quot;&gt;&lt;/a&gt;困难&lt;/h2&gt;&lt;p&gt;在自己开发学习过程中，主要遇到了两个难点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加过多图片时，会出现OOM。&lt;/li&gt;
&lt;li&gt;如何动态修改图片展示栏的高度。&lt;/li&gt;
&lt;li&gt;加号如何伴随图片的增加而后移。&lt;/li&gt;
&lt;li&gt;如何保证最多添加照片为9张。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;难点解决&quot;&gt;&lt;a href=&quot;#难点解决&quot; class=&quot;headerlink&quot; title=&quot;难点解决&quot;&gt;&lt;/a&gt;难点解决&lt;/h2&gt;&lt;h3 id=&quot;添加过多图片时，会出现OOM&quot;&gt;&lt;a href=&quot;#添加过多图片时，会出现OOM&quot; class=&quot;headerlink&quot; title=&quot;添加过多图片时，会出现OOM&quot;&gt;&lt;/a&gt;添加过多图片时，会出现OOM&lt;/h3&gt;&lt;p&gt;出现第一种情况的原因很简单，就是随着我们手机的像素越来越高，图片的大小也越来越大，我们普通的机拍出来照片至少也有1~2M，更不说像素高的手机。而对于一个安卓应用来说，由于手机设备的限制，一般应用使用的RAM不能超过某个设定值，不同产商默认值不太一样，一般常见的有16M，24M，32M,48M。所以一个Activity中加载几张高清原图，就会报Out Of Memory 错误，也就是所谓的OOM错误。所以知道了这个问题之后我们就很容易解决了，我们就可以先将图片压缩，然后再使用ImageView加载压缩后的图片即可。而我们这里是通过对图片的尺寸进行压缩实现图片的压缩，这里大概说一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;要对图片压缩，首先要先将BitmapFactory.Options中的inJustDecodeBounds设置为true。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final BitmapFactory.Options options = new BitmapFactory.Options();
// 若要对图片进行压缩，必须先设置Option的inJustDecodeBounds为true
options.inJustDecodeBounds = true;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后通过BitmapFactory中decodeFile方法来获取到照片的高度和宽度，这里只要存进一个图片地址即可。获取图片地址这里就不详讲了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BitmapFactory.decodeFile(pathName，options)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;然后需要对BitmapFactory.Options中的inSampleSize根据你需要压缩比例进行设置，options.inSampleSize是图片的压缩比，例如原来大小是100 &lt;em&gt; 100，options.inSampleSize为1，则不变，options.inSampleSize为2，则压缩成50 &lt;/em&gt; 50。而我这里是根据自己设置最低宽度和最低高度来获取inSampleSize的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;
    if (height &amp;gt; reqHeight || width &amp;gt; reqWidth) {
        //首先获取原图高度和宽度的一半
        final int halfHeight = height / 2;
        final int halfWidth = width / 2;
        //循环，如果halfHeight和halfWidth同时大于最小宽度和最小高度时，inSampleSize乘2，
        //最后得到的宽或者高都是最接近最小宽度或者最小高度的
        while ((halfHeight / inSampleSize) &amp;gt; reqHeight &amp;amp;&amp;amp; (halfWidth / inSampleSize) &amp;gt; reqWidth) {
            inSampleSize *= 2;
        }
    }
    return inSampleSize;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取到inSampleSize值之后，重新设置options.inJustDecodeBounds为false，不能修改option，调用BitmapFactory中的decodeFile方法即可获取到压缩后的照片，这样在加载图片时就可以避免OOM的出现了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;options.inJustDecodeBounds = false;
// 根据options重新加载图片
Bitmap src = BitmapFactory.decodeFile(pathName, options);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，我将按尺寸压缩照片的功能包装成BitmapUtil类，在使用时直接调用即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BitmapUtils {

    private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 1;
        if (height &amp;gt; reqHeight || width &amp;gt; reqWidth) {
            final int halfHeight = height / 2;
            final int halfWidth = width / 2;
            while ((halfHeight / inSampleSize) &amp;gt; reqHeight &amp;amp;&amp;amp; (halfWidth / inSampleSize) &amp;gt; reqWidth) {
                inSampleSize *= 2;
            }
        }
        return inSampleSize;
    }

    /**
     * 根据Resources压缩图片
     * 
     * @param res
     * @param resId
     * @param reqWidth
     * @param reqHeight
     * @return
     */
    public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeResource(res, resId, options);
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
        options.inJustDecodeBounds = false;
        Bitmap src = BitmapFactory.decodeResource(res, resId, options);
        return src;
    }

    /**
     * 根据地址压缩图片
     * 
     * @param pathName
     * @param reqWidth
     * @param reqHeight
     * @return
     */
    public static Bitmap decodeSampledBitmapFromFd(String pathName, int reqWidth, int reqHeight) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(pathName, options);
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);
        options.inJustDecodeBounds = false;
        Bitmap src = BitmapFactory.decodeFile(pathName, options);
        return src;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;如何动态修改图片展示栏的高度&quot;&gt;&lt;a href=&quot;#如何动态修改图片展示栏的高度&quot; class=&quot;headerlink&quot; title=&quot;如何动态修改图片展示栏的高度&quot;&gt;&lt;/a&gt;如何动态修改图片展示栏的高度&lt;/h3&gt;&lt;p&gt;如何动态修改图片展示栏的高度，首先我说一下我是使用GridView来实现图片栏的展示，所以我们可以在第一次加载GridView时可以获取到下图的参数，大家看图会容易理解一点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们的照片如果只有一栏，则GridView的高度不变&lt;/li&gt;
&lt;li&gt;如果照片有两栏，则高度设置为gridViewH * 2 - (gridViewH - imageViewH) / 2&lt;/li&gt;
&lt;li&gt;如果有三栏，则GrideView的高度设置为gridViewH * 3 - (gridViewH - imageViewH)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-SendPhotoUI3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们在第一次加载GridView时记录GridView的高度GridViewH。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LinearLayout.LayoutParams params =(android.widget.LinearLayout.LayoutParams) mGridView.getLayoutParams();

gridViewH = params.height;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同时记录ImageView的高度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RelativeLayout.LayoutParams params = (android.widget.RelativeLayout.LayoutParams) holder.imageView
            .getLayoutParams();
imageViewH = params.height;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;则上下的边距为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(gridViewH - imageViewH) / 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将它写成一个方法，在每次getView()方法中调用即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void setGridView() {
    LinearLayout.LayoutParams lp = (android.widget.LinearLayout.LayoutParams) mGridView.getLayoutParams();
    if (data.size() &amp;lt; 4) {
        lp.height = gridViewH;
    } else if (data.size() &amp;lt; 8) {
        lp.height = gridViewH * 2 - (gridViewH - imageViewH) / 2;
    } else {
        lp.height = gridViewH * 3 - (gridViewH - imageViewH);
    }
    mGridView.setLayoutParams(lp);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;加号如何伴随图片的增加而后移&quot;&gt;&lt;a href=&quot;#加号如何伴随图片的增加而后移&quot; class=&quot;headerlink&quot; title=&quot;加号如何伴随图片的增加而后移&quot;&gt;&lt;/a&gt;加号如何伴随图片的增加而后移&lt;/h3&gt;&lt;p&gt;因为我的数据源是List&lt;bitmap&gt;，所以可以这么做：&lt;/bitmap&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当第一次加载时，List中只有一张加号的照片&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当添加了照片之后，List先移除加号照片，再添加照片，最后再把加号照片添加进去&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data.remove(data.size() - 1);
Bitmap bp = BitmapFactory.decodeResource(getResources(), R.drawable.ic_addpic);
data.add(newBp);
data.add(bp);
//将路径设置为空，防止在手机休眠后返回Activity调用此方法时添加照片
photoPath = null;
adapter.notifyDataSetChanged();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何保证最多添加照片为9张&quot;&gt;&lt;a href=&quot;#如何保证最多添加照片为9张&quot; class=&quot;headerlink&quot; title=&quot;如何保证最多添加照片为9张&quot;&gt;&lt;/a&gt;如何保证最多添加照片为9张&lt;/h3&gt;&lt;p&gt;这个问题只需要在每次添加之前判断数据源的大小是否为10（包括加号照片，大小就为10）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (data.size() == 10) {
    Toast.makeText(MainActivity.this, &amp;quot;图片数9张已满&amp;quot;, Toast.LENGTH_SHORT).show();
} else {
    if (position == data.size() - 1) {
        Toast.makeText(MainActivity.this, &amp;quot;添加图片&amp;quot;, Toast.LENGTH_SHORT).show();
        // 选择图片
        Intent intent = new Intent(Intent.ACTION_PICK, null);
        intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &amp;quot;image/*&amp;quot;);
        startActivityForResult(intent, 0x1);
    } else {
        Toast.makeText(MainActivity.this, &amp;quot;点击第&amp;quot; + (position + 1) + &amp;quot; 号图片&amp;quot;, Toast.LENGTH_SHORT).show();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;界面&quot;&gt;&lt;a href=&quot;#界面&quot; class=&quot;headerlink&quot; title=&quot;界面&quot;&gt;&lt;/a&gt;界面&lt;/h2&gt;&lt;p&gt;activity_main.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ScrollView xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:background=&amp;quot;#F3F6F8&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;

    &amp;lt;LinearLayout
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:orientation=&amp;quot;vertical&amp;quot; &amp;gt;

        &amp;lt;ImageView
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;1dp&amp;quot;
            android:layout_marginTop=&amp;quot;2dp&amp;quot;
            android:src=&amp;quot;#E4E3E3&amp;quot; /&amp;gt;

        &amp;lt;EditText
            android:id=&amp;quot;@+id/content_et&amp;quot;
            android:layout_width=&amp;quot;fill_parent&amp;quot;
            android:layout_height=&amp;quot;120dp&amp;quot;
            android:background=&amp;quot;#FFFFFF&amp;quot;
            android:gravity=&amp;quot;top&amp;quot;
            android:hint=&amp;quot;随手说出你此刻的心声...&amp;quot;
            android:maxLength=&amp;quot;500&amp;quot;
            android:padding=&amp;quot;5dp&amp;quot;
            android:singleLine=&amp;quot;false&amp;quot;
            android:textColor=&amp;quot;#000000&amp;quot;
            android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;

        &amp;lt;ImageView
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;1dp&amp;quot;
            android:src=&amp;quot;#E4E3E3&amp;quot; /&amp;gt;

        &amp;lt;ImageView
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;1dp&amp;quot;
            android:layout_marginTop=&amp;quot;10dp&amp;quot;
            android:src=&amp;quot;#E4E3E3&amp;quot; /&amp;gt;

        &amp;lt;GridView
            android:id=&amp;quot;@+id/gridView1&amp;quot;
            android:layout_width=&amp;quot;fill_parent&amp;quot;
            android:layout_height=&amp;quot;100dp&amp;quot;
            android:background=&amp;quot;#FFFFFF&amp;quot;
            android:columnWidth=&amp;quot;90dp&amp;quot;
            android:gravity=&amp;quot;center&amp;quot;
            android:horizontalSpacing=&amp;quot;5dp&amp;quot;
            android:numColumns=&amp;quot;4&amp;quot;
            android:padding=&amp;quot;10dp&amp;quot;
            android:stretchMode=&amp;quot;columnWidth&amp;quot;
            android:verticalSpacing=&amp;quot;5dp&amp;quot; &amp;gt;
        &amp;lt;/GridView&amp;gt;

        &amp;lt;ImageView
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;1dp&amp;quot;
            android:src=&amp;quot;#E4E3E3&amp;quot; /&amp;gt;

        &amp;lt;Button
            android:id=&amp;quot;@+id/send_btn&amp;quot;
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;wrap_content&amp;quot;
            android:layout_gravity=&amp;quot;center&amp;quot;
            android:layout_marginLeft=&amp;quot;35dp&amp;quot;
            android:layout_marginRight=&amp;quot;35dp&amp;quot;
            android:layout_marginTop=&amp;quot;20dp&amp;quot;
            android:background=&amp;quot;@drawable/send_btn_selector&amp;quot;
            android:gravity=&amp;quot;center&amp;quot;
            android:text=&amp;quot;发送&amp;quot;
            android:textColor=&amp;quot;#FFFFFF&amp;quot;
            android:textSize=&amp;quot;20sp&amp;quot; /&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;

&amp;lt;/ScrollView&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;griditem.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;80dp&amp;quot;
    android:layout_height=&amp;quot;80dp&amp;quot;
    android:descendantFocusability=&amp;quot;blocksDescendants&amp;quot;
    android:gravity=&amp;quot;center&amp;quot; &amp;gt;

    &amp;lt;ImageView
        android:id=&amp;quot;@+id/imageView1&amp;quot;
        android:layout_width=&amp;quot;80dp&amp;quot;
        android:layout_height=&amp;quot;80dp&amp;quot;
        android:scaleType=&amp;quot;centerCrop&amp;quot;
        android:src=&amp;quot;@drawable/ic_addpic&amp;quot; /&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Demo下载&quot;&gt;&lt;a href=&quot;#Demo下载&quot; class=&quot;headerlink&quot; title=&quot;Demo下载&quot;&gt;&lt;/a&gt;Demo下载&lt;/h2&gt;&lt;p&gt;Github:&lt;a href=&quot;https://github.com/ryanlijianchang/TestUpload&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ryanlijianchang/TestUpload&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSDN: &lt;a href=&quot;http://download.csdn.net/detail/ljcitworld/9549313&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.csdn.net/detail/ljcitworld/9549313&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;后话&quot;&gt;&lt;a href=&quot;#后话&quot; class=&quot;headerlink&quot; title=&quot;后话&quot;&gt;&lt;/a&gt;后话&lt;/h2&gt;&lt;p&gt;博主只是实现了这一个UI界面，我们开发过程中肯定要实现图片，文字的上传等，这里博主就不再详述了，大家可以看我的另一篇博文&lt;a href=&quot;http://blog.csdn.net/ljcitworld/article/details/51670910&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android学习-使用Async-Http实现图片压缩并上传功能&lt;/a&gt;，就这个例子而言，大家如果需要上传多张照片，就可以在添加完照片之后将bitmap存起来，然后通过循环容器的大小，然后每一张图片再上传到服务器即可。还是那句话，&lt;strong&gt;个人能力有限，欢迎大家一起交流学习，我也会虚心接纳大家的指教，不喜勿喷。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/displaying-bitmaps/load-bitmap.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Developer:Loading Large Bitmaps Efficiently&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;功能需求&quot;&gt;&lt;a href=&quot;#功能需求&quot; class=&quot;headerlink&quot; title=&quot;功能需求&quot;&gt;&lt;/a&gt;功能需求&lt;/h2&gt;&lt;p&gt;最近自己在开发一个社交APP，发送动态（类似朋友圈）是社交APP必备的一个功能，而自己在开发过程中也需要开发到这一个功能，但是在开发中遇到了一个问题，就是如何绘制一个类似朋友群那样动态添加图片，并加号随着自己的图片增加而后移这一个UI，而这篇小文就是教你如何制作一个仿朋友圈发带图朋友圈的UI设计。注意，这是UI设计，并不是实现图片上传功能。&lt;/p&gt;
&lt;p&gt;当然，如果你想知道如何实现图片上传到服务器，请看我的另一篇文章：&lt;a href=&quot;http://blog.csdn.net/ljcitworld/article/details/51670910&quot;&gt;Android学习-使用Async-Http实现图片压缩并上传功能&lt;/a&gt;。个人水平有限，如有不足的地方，欢迎交流，勿喷。&lt;/p&gt;
    
    </summary>
    
      <category term="Android学习" scheme="lijianchang.xyz/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="UI设计" scheme="lijianchang.xyz/tags/UI%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android技能-创建Json文本及Json解析</title>
    <link href="lijianchang.xyz/2016/08/30/Android%E6%8A%80%E8%83%BD-%E5%88%9B%E5%BB%BAJson%E6%96%87%E6%9C%AC%E5%8F%8AJson%E8%A7%A3%E6%9E%90/"/>
    <id>lijianchang.xyz/2016/08/30/Android技能-创建Json文本及Json解析/</id>
    <published>2016-08-30T01:49:30.348Z</published>
    <updated>2016-08-30T03:52:41.157Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Json数据在安卓开发过程中是非常常见的，在请求服务器端数据的时候，服务器端返回的无非就是三种类型：HTML，XML，JSON。所以学习JSON对安卓程序员来说是非常重要的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;什么是JSON&quot;&gt;&lt;a href=&quot;#什么是JSON&quot; class=&quot;headerlink&quot; title=&quot;什么是JSON&quot;&gt;&lt;/a&gt;什么是JSON&lt;/h2&gt;&lt;p&gt;JSON：JavaScript Object Notation。顾名思义，JSON数据是源自于JavaScript，学习过JavaScript（以下简称JS）的人都知道，我们在JS脚本里面创建对象时，都是以键值对的形式编写的。例如，我们在JS里面创建一个Json对象时是这么定义的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var person = {firstName:&amp;quot;John&amp;quot;, lastName:&amp;quot;Doe&amp;quot;, age:50, eyeColor:&amp;quot;blue&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很容易看出，属性之间是通过逗号分隔开，键与值之间是通过双引号分隔开，而JSON数据也是如此。&lt;/p&gt;
&lt;h2 id=&quot;JSON的数据类型&quot;&gt;&lt;a href=&quot;#JSON的数据类型&quot; class=&quot;headerlink&quot; title=&quot;JSON的数据类型&quot;&gt;&lt;/a&gt;JSON的数据类型&lt;/h2&gt;&lt;p&gt;json一共有两种数据结构。&lt;/p&gt;
&lt;h3 id=&quot;JsonObject&quot;&gt;&lt;a href=&quot;#JsonObject&quot; class=&quot;headerlink&quot; title=&quot;JsonObject&quot;&gt;&lt;/a&gt;JsonObject&lt;/h3&gt;&lt;p&gt;一种是以 (key/value)对形式存在的无序的jsonObject对象。对象使用大括号括起来，属性之间使用逗号分隔开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/432441/201311/27202314-f6689071fd2444f18e2db818071ad990.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;例如：{“name”: “jack”}， 这就是一个最简单的json对象，对于这种数据格式，key值必须要是string类型，而对于value，则可以是string、number、object、array等数据类型。&lt;/p&gt;
&lt;h3 id=&quot;JsonArray&quot;&gt;&lt;a href=&quot;#JsonArray&quot; class=&quot;headerlink&quot; title=&quot;JsonArray&quot;&gt;&lt;/a&gt;JsonArray&lt;/h3&gt;&lt;p&gt;另一种数据格式就是有序的value的集合，这种形式被称为是JsonArray。数组是值的有序集合，值与值之间使用逗号分隔开，集合用中括号括起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/432441/201311/27202539-5ecbee4dffaa4388998dd3118948ec48.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建JSON文本&quot;&gt;&lt;a href=&quot;#创建JSON文本&quot; class=&quot;headerlink&quot; title=&quot;创建JSON文本&quot;&gt;&lt;/a&gt;创建JSON文本&lt;/h2&gt;&lt;p&gt;例如我们要创建以下类型的Jjson数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;person&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;zhangsan&amp;quot;, &amp;quot;phone&amp;quot;:[&amp;quot;123&amp;quot;, &amp;quot;456&amp;quot;],&amp;quot;address&amp;quot;:&amp;quot;guangdong&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用JSONOject和JSONArray创建&quot;&gt;&lt;a href=&quot;#使用JSONOject和JSONArray创建&quot; class=&quot;headerlink&quot; title=&quot;使用JSONOject和JSONArray创建&quot;&gt;&lt;/a&gt;使用JSONOject和JSONArray创建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 * 使用JsonObject和JsonArray创建JSON对象
 */
public void makeJson() {
    try {
        JSONObject object = new JSONObject();

        JSONObject person = new JSONObject();
        //名字
        person.put(&amp;quot;name&amp;quot;, &amp;quot;zhangsan&amp;quot;);
        //电话
        JSONArray phone = new JSONArray();
        phone.put(&amp;quot;123&amp;quot;).put(&amp;quot;456&amp;quot;);
        person.put(&amp;quot;phone&amp;quot;, phone);
        //地址
        person.put(&amp;quot;address&amp;quot;, &amp;quot;guangdong&amp;quot;);

        object.put(&amp;quot;person&amp;quot;, person);

        Log.i(&amp;quot;JSON_LOG&amp;quot;, object.toString());
    } catch (JSONException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-Json1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用JsonStringer创建&quot;&gt;&lt;a href=&quot;#使用JsonStringer创建&quot; class=&quot;headerlink&quot; title=&quot;使用JsonStringer创建&quot;&gt;&lt;/a&gt;使用JsonStringer创建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 * 通过JsonStringer创建JSON对象
 */
public void makeJsonStringer() {
    try {
        JSONStringer jsonText = new JSONStringer();
        // 首先是{，对象开始。object和endObject必须配对使用
        jsonText.object();

        jsonText.key(&amp;quot;person&amp;quot;);

        jsonText.object();

        jsonText.key(&amp;quot;name&amp;quot;);
        jsonText.value(&amp;quot;zhangsan&amp;quot;);

        jsonText.key(&amp;quot;phone&amp;quot;);
        // 键phone的值是数组。array和endArray必须配对使用
        jsonText.array();
        jsonText.value(&amp;quot;123&amp;quot;).value(&amp;quot;456&amp;quot;);
        jsonText.endArray();

        jsonText.key(&amp;quot;address&amp;quot;);
        jsonText.value(&amp;quot;Guangdong&amp;quot;);

        jsonText.endObject();

        jsonText.endObject();


        Log.i(&amp;quot;JSON_LOG&amp;quot;, jsonText.toString());
    } catch (JSONException ex) {
        throw new RuntimeException(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-Json2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JSON解析&quot;&gt;&lt;a href=&quot;#JSON解析&quot; class=&quot;headerlink&quot; title=&quot;JSON解析&quot;&gt;&lt;/a&gt;JSON解析&lt;/h2&gt;&lt;h3 id=&quot;1-解析-“key”-“Object”-类型的&quot;&gt;&lt;a href=&quot;#1-解析-“key”-“Object”-类型的&quot; class=&quot;headerlink&quot; title=&quot;1. 解析{“key”, “Object”}类型的&quot;&gt;&lt;/a&gt;1. 解析{“key”, “Object”}类型的&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;{&amp;quot;person&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;zhangsan&amp;quot;, &amp;quot;phone&amp;quot;:[&amp;quot;123&amp;quot;, &amp;quot;456&amp;quot;],&amp;quot;address&amp;quot;:&amp;quot;guangdong&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解析代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * JSON解析
 * @param json
 * @return
 */
public static String JsonToString(String json) {
    Person person = new Person();
    try {
        //获取到整个Json数据
        JSONObject object = new JSONObject(json);
        //解析最外层，获得person键对应的object值
        JSONObject personObject = object.getJSONObject(&amp;quot;person&amp;quot;);
        //解析object值里面的每一个属性
        person.setName(personObject.getString(&amp;quot;name&amp;quot;));
        //属性值是数组，则使用JSONArray获取
        JSONArray phoneArray = personObject.getJSONArray(&amp;quot;phone&amp;quot;);
        List&amp;lt;String&amp;gt; phone = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; phoneArray.length(); i++) {
            phone.add((String) phoneArray.get(i));
        }
        person.setPhone(phone);
        person.setAddress(personObject.getString(&amp;quot;address&amp;quot;));
    } catch (JSONException e) {
        e.printStackTrace();
    }
    return person.toString();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-Json3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-解析-“Object”-类型&quot;&gt;&lt;a href=&quot;#2-解析-“Object”-类型&quot; class=&quot;headerlink&quot; title=&quot;2. 解析{“Object”}类型&quot;&gt;&lt;/a&gt;2. 解析{“Object”}类型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;{&amp;quot;name&amp;quot;:&amp;quot;zhangsan&amp;quot;, &amp;quot;phone&amp;quot;:[&amp;quot;123&amp;quot;, &amp;quot;456&amp;quot;],&amp;quot;address&amp;quot;:&amp;quot;guangdong&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这么解析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /**
 * 解析单个对象的JSON数据
 * @param json
 * @return
 */
public static String JsonParse(String json) {
    Person person = new Person();
    try {
        JSONObject personObject = new JSONObject(json);
        //解析object值里面的每一个属性
        person.setName(personObject.getString(&amp;quot;name&amp;quot;));
        //属性值是数组，则使用JSONArray获取
        JSONArray phoneArray = personObject.getJSONArray(&amp;quot;phone&amp;quot;);
        List&amp;lt;String&amp;gt; phone = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; phoneArray.length(); i++) {
            phone.add((String) phoneArray.get(i));
        }
        person.setPhone(phone);
        person.setAddress(personObject.getString(&amp;quot;address&amp;quot;));
    } catch (JSONException e) {
        e.printStackTrace();
    }

    return person.toString();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-解析-“value”-类型&quot;&gt;&lt;a href=&quot;#3-解析-“value”-类型&quot; class=&quot;headerlink&quot; title=&quot;3. 解析{“value”}类型&quot;&gt;&lt;/a&gt;3. 解析{“value”}类型&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[&amp;quot;123&amp;quot;, &amp;quot;456&amp;quot;, &amp;quot;789&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解析方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 解析数组型的JSON数据
 * @param json
 * @return
 */
public static List&amp;lt;String&amp;gt; JsonParseToArray(String json){
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    try {
        JSONArray array = new JSONArray(json);
        for (int i=0; i&amp;lt;array.length(); i++){
            list.add((String) array.get(i));
        }
    } catch (JSONException e) {
        e.printStackTrace();
    }
    return list;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;解析总结&quot;&gt;&lt;a href=&quot;#解析总结&quot; class=&quot;headerlink&quot; title=&quot;解析总结&quot;&gt;&lt;/a&gt;解析总结&lt;/h3&gt;&lt;p&gt;JSON解析无非就是通过JSONObject和JSONArray不断地对数据进行解析，归根结底每一种数据都是可以分解为以上的三种最基本的解析，所以大家只要掌握好JSONObject和JSONArray，即便再复杂的数据类型，大家也可以解析得得心应手。&lt;/p&gt;
&lt;h2 id=&quot;GSON&quot;&gt;&lt;a href=&quot;#GSON&quot; class=&quot;headerlink&quot; title=&quot;GSON&quot;&gt;&lt;/a&gt;GSON&lt;/h2&gt;&lt;p&gt;GSON是Google开发的开源的JAVA API，可以用于JSON的创建和JSON的解析。下面对GSON做一个最基本的介绍。更多了解 &lt;a href=&quot;http://sites.google.com/site/gson/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sites.google.com/site/gson/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先需要下载GSON的jar包，自行度娘。&lt;/p&gt;
&lt;p&gt;其次，我们使用GSON来创建JSON和解析JSON都要有相对应的JavaBean，所以GSON可以帮助我们更加简便地实现Bean和JSON的转换。&lt;/p&gt;
&lt;p&gt;以下例子我们都是用Person类的JavaBean:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Person {
    private String name;
    private List&amp;lt;String&amp;gt; phone;
    private String address;

    public Person() {

    }

    public Person(String name, List&amp;lt;String&amp;gt; phone, String address) {
        this.name = name;
        this.phone = phone;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List&amp;lt;String&amp;gt; getPhone() {
        return phone;
    }

    public void setPhone(List&amp;lt;String&amp;gt; phone) {
        this.phone = phone;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &amp;quot;Person{&amp;quot; +
                &amp;quot;name=&amp;apos;&amp;quot; + name + &amp;apos;\&amp;apos;&amp;apos; +
                &amp;quot;, phone=&amp;quot; + phone +
                &amp;quot;, address=&amp;apos;&amp;quot; + address + &amp;apos;\&amp;apos;&amp;apos; +
                &amp;apos;}&amp;apos;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Bean转换为JSON&quot;&gt;&lt;a href=&quot;#Bean转换为JSON&quot; class=&quot;headerlink&quot; title=&quot;Bean转换为JSON&quot;&gt;&lt;/a&gt;Bean转换为JSON&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 * GSON转换为JSON
 *
 * @return json
 */
public String beanToJson() {

    //赋值给一个person实例
    List&amp;lt;String&amp;gt; phone = new ArrayList&amp;lt;&amp;gt;();
    phone.add(&amp;quot;123&amp;quot;);
    phone.add(&amp;quot;456&amp;quot;);
    Person person = new Person(&amp;quot;jack&amp;quot;, phone, &amp;quot;Guangzhou&amp;quot;);

    //实例化GSON
    Gson gson = new Gson();
    //调用gson.toJson将Bean转为JSON
    String json = gson.toJson(person);
    return json;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;JSON转换为Bean&quot;&gt;&lt;a href=&quot;#JSON转换为Bean&quot; class=&quot;headerlink&quot; title=&quot;JSON转换为Bean&quot;&gt;&lt;/a&gt;JSON转换为Bean&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 * JSON转换为Bean
 * @param json
 * @return
 */
public String jsonToBean(String json) {
    Person person = new Person();
    Gson gson = new Gson();
    //调用gson.fromJson将json转为bean
    person = gson.fromJson(json, Person.class);
    return person.toString();
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Json数据在安卓开发过程中是非常常见的，在请求服务器端数据的时候，服务器端返回的无非就是三种类型：HTML，XML，JSON。所以学习JSON对安卓程序员来说是非常重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="Android技能" scheme="lijianchang.xyz/categories/Android%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="JSON" scheme="lijianchang.xyz/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Android学习-简易ViewPager的使用教程与Demo演示</title>
    <link href="lijianchang.xyz/2016/08/30/Android%E5%AD%A6%E4%B9%A0-%E7%AE%80%E6%98%93ViewPager%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%B8%8EDemo%E6%BC%94%E7%A4%BA/"/>
    <id>lijianchang.xyz/2016/08/30/Android学习-简易ViewPager的使用教程与Demo演示/</id>
    <published>2016-08-30T01:49:03.187Z</published>
    <updated>2016-08-30T03:52:27.261Z</updated>
    
    <content type="html">&lt;p&gt;摘要：最近在项目开发中使用到了ViewPager，结合自己几天下来的学习，总结一下ViewPager的使用方法以及实现过程。&lt;/p&gt;
&lt;h2 id=&quot;实例效果&quot;&gt;&lt;a href=&quot;#实例效果&quot; class=&quot;headerlink&quot; title=&quot;实例效果&quot;&gt;&lt;/a&gt;实例效果&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-HowToUseVP-show.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是谷歌&lt;a href=&quot;http://www.android-doc.com/reference/android/support/v4/view/ViewPager.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;给我们提供的一个兼容包里面的类，它说我们的ViewPager通常是配合Fragment使用的，而官方是提供了FragmentPagerAdapter和FragmentStatePagerAdapter两种方便我们将ViewPager和Fragment配合使用。下面我们主要讲ViewPager+Fragment的使用。&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-HowToUseVP-guanfang.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Demo剖析&quot;&gt;&lt;a href=&quot;#Demo剖析&quot; class=&quot;headerlink&quot; title=&quot;Demo剖析&quot;&gt;&lt;/a&gt;Demo剖析&lt;/h2&gt;&lt;p&gt;这个Demo的难点主要在以下三部分，那么我们下面就对这三个部分进行剖析。&lt;/p&gt;
&lt;h3 id=&quot;一、top-bar部分&quot;&gt;&lt;a href=&quot;#一、top-bar部分&quot; class=&quot;headerlink&quot; title=&quot;一、top_bar部分&quot;&gt;&lt;/a&gt;一、top_bar部分&lt;/h3&gt;&lt;p&gt;这部分我们只需要设置一个外布局为LinearLayout（注意！这个Layout的高度一定不能为match_parent，只能为wrap_content，因为如果你这里使用了match_parent的话，那么就会遮挡了下面的ViewPager控件，详见我的main.xml布局文件以及top_bar.xml 布局文件，我的主布局为了代码布局清晰，所以通过定义了top_bar的layout，然后通过引入即可。）&lt;/p&gt;
&lt;h3 id=&quot;二、下标部分&quot;&gt;&lt;a href=&quot;#二、下标部分&quot; class=&quot;headerlink&quot; title=&quot;二、下标部分&quot;&gt;&lt;/a&gt;二、下标部分&lt;/h3&gt;&lt;p&gt;下标部分我们是通过一个imageview来实现。将此ImageView的背景设为一个蓝色的点九图，然后再逻辑文件中设置它的长度以及在滑动时的位置变化即可。&lt;/p&gt;
&lt;p&gt;设置滑动条的宽度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; /**
  * 设置滑动条的宽度为屏幕的1/3(根据Tab的个数而定)
  */
private void initTabLineWidth() {
    DisplayMetrics dpMetrics = new DisplayMetrics();
    getWindow().getWindowManager().getDefaultDisplay().getMetrics(dpMetrics);
    screenWidth = dpMetrics.widthPixels;
    LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) tab.getLayoutParams();
    lp.width = screenWidth / 3;
    tab.setLayoutParams(lp);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在onPagerScrolled方法中设置滑动条的位置变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @Override
 public void onPageScrolled(int position, float offset,
                                   int offsetPixels) {
     LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) tablineIv.getLayoutParams();
    Log.i(&amp;quot;mOffset&amp;quot;, &amp;quot;offset:&amp;quot; + offset + &amp;quot;,position:&amp;quot; + position);

    if (currentIndex == 0 &amp;amp;&amp;amp; position == 0)// 0-&amp;gt;1
    {
        lp.leftMargin = (int) (offset * (screenWidth * 1.0 / 3) + currentIndex
                        * (screenWidth / 3));
    } else if (currentIndex == 1 &amp;amp;&amp;amp; position == 0) // 1-&amp;gt;0
    {
        lp.leftMargin = (int) (-(1 - offset) * (screenWidth * 1.0 / 3) + currentIndex * (screenWidth / 3));
    } else if (currentIndex == 1 &amp;amp;&amp;amp; position == 1) // 1-&amp;gt;2
    {
        lp.leftMargin = (int) (offset * (screenWidth * 1.0 / 3) + currentIndex
                        * (screenWidth / 3));
    } else if (currentIndex == 2 &amp;amp;&amp;amp; position == 1) // 2-&amp;gt;1
    {
        lp.leftMargin = (int) (-(1 - offset) * (screenWidth * 1.0 / 3) + currentIndex * (screenWidth / 3));
    }
    tablineIv.setLayoutParams(lp);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;三、ViewPager实现部分&quot;&gt;&lt;a href=&quot;#三、ViewPager实现部分&quot; class=&quot;headerlink&quot; title=&quot;三、ViewPager实现部分&quot;&gt;&lt;/a&gt;三、ViewPager实现部分&lt;/h3&gt;&lt;p&gt;ViewPager的实现主要通过以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;把包含的Fragement存放到一个容器List里面去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个FragmentPagerAdapter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为ViewPager绑定此FragmentPagerAdapter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ViewPager设置默认当前的项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ViewPager设置监听器，需要重写onPageScrollStateChanged，onPageScrolled，onPageSelected三个方法  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h2&gt;&lt;h3 id=&quot;一、界面部分&quot;&gt;&lt;a href=&quot;#一、界面部分&quot; class=&quot;headerlink&quot; title=&quot;一、界面部分&quot;&gt;&lt;/a&gt;一、界面部分&lt;/h3&gt;&lt;p&gt;在界面部分，需要将我们的顶部的内容和ViewPager分开。如下我们将top_bar内容和ViewPager分开。&lt;/p&gt;
&lt;p&gt;main.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;

    &amp;lt;!-- 顶部的内容 --&amp;gt;
    &amp;lt;include layout=&amp;quot;@layout/top_bar&amp;quot; /&amp;gt;

    &amp;lt;!-- ViewPager --&amp;gt;
    &amp;lt;android.support.v4.view.ViewPager
        android:id=&amp;quot;@+id/viewpager&amp;quot;
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;0dp&amp;quot;
        android:layout_weight=&amp;quot;1&amp;quot; &amp;gt;
    &amp;lt;/android.support.v4.view.ViewPager&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;top_bar.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
    &amp;lt;!--注意最外层布局的高度不能使用match_parent，不然将会遮挡了ViewPager部分--&amp;gt;
    &amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    xmlns:tools=&amp;quot;http://schemas.android.com/tools&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;


    &amp;lt;LinearLayout
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:baselineAligned=&amp;quot;false&amp;quot;
        android:orientation=&amp;quot;horizontal&amp;quot;&amp;gt;

        &amp;lt;TextView
            android:id=&amp;quot;@+id/mainTv&amp;quot;
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;50dp&amp;quot;
            android:layout_weight=&amp;quot;1&amp;quot;
            android:gravity=&amp;quot;center&amp;quot;
            android:text=&amp;quot;首页&amp;quot;
            android:textColor=&amp;quot;#0000FF&amp;quot;
            android:textSize=&amp;quot;18dp&amp;quot; /&amp;gt;

        &amp;lt;TextView
            android:id=&amp;quot;@+id/momentTv&amp;quot;
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;50dp&amp;quot;
            android:layout_weight=&amp;quot;1&amp;quot;
            android:gravity=&amp;quot;center&amp;quot;
            android:text=&amp;quot;朋友圈&amp;quot;
            android:textColor=&amp;quot;@android:color/black&amp;quot;
            android:textSize=&amp;quot;18dp&amp;quot; /&amp;gt;

        &amp;lt;TextView
            android:id=&amp;quot;@+id/settingTv&amp;quot;
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;50dp&amp;quot;
            android:layout_weight=&amp;quot;1&amp;quot;
            android:gravity=&amp;quot;center&amp;quot;
            android:text=&amp;quot;设置&amp;quot;
            android:textColor=&amp;quot;@android:color/black&amp;quot;
            android:textSize=&amp;quot;18dp&amp;quot; /&amp;gt;


    &amp;lt;/LinearLayout&amp;gt;

    &amp;lt;ImageView
        android:id=&amp;quot;@+id/iv_tabline&amp;quot;
        android:layout_width=&amp;quot;200dp&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:contentDescription=&amp;quot;tab&amp;quot;
        android:background=&amp;quot;@drawable/tab&amp;quot; &amp;gt;
    &amp;lt;/ImageView&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有我们的三个Fragment界面，基本一致。&lt;/p&gt;
&lt;p&gt;fragment_main.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

    &amp;lt;TextView
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        android:gravity=&amp;quot;center&amp;quot;
        android:text=&amp;quot;首页&amp;quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fragment_moment.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

    &amp;lt;TextView
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        android:gravity=&amp;quot;center&amp;quot;
        android:text=&amp;quot;朋友圈&amp;quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fragment_setting.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;

    &amp;lt;TextView
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        android:gravity=&amp;quot;center&amp;quot;
        android:text=&amp;quot;设置&amp;quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二、逻辑代码&quot;&gt;&lt;a href=&quot;#二、逻辑代码&quot; class=&quot;headerlink&quot; title=&quot;二、逻辑代码&quot;&gt;&lt;/a&gt;二、逻辑代码&lt;/h3&gt;&lt;p&gt;MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.example.ryan.viewpagerdemo;

import android.graphics.Color;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.util.DisplayMetrics;
import android.util.Log;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import java.util.ArrayList;
import java.util.List;

/**
 * MainActivity需要继承FragmentActivity
 */
public class MainActivity extends FragmentActivity {
    private ViewPager viewPager;
    private List&amp;lt;Fragment&amp;gt; mFragmentList = new ArrayList&amp;lt;Fragment&amp;gt;();
    private FragmentAdapter mFragmentAdapter;

    //Tab显示内容TextView
    private TextView mainTv, momentTv, settingTv;
    //Tab的那个引导线
    private ImageView tablineIv;

    //三个Fragment页面
    private MainFragment mainFg;
    private MomentFragment momentFg;
    private SettingFragment settingFg;

    //ViewPager的当前选中页
    private int currentIndex;

    //屏幕的宽度
    private int screenWidth;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        findById();
        init();
        initTabLineWidth();

    }

    /**
     * 找到控件ID
     */
    private void findById() {
        mainTv = (TextView) this.findViewById(R.id.mainTv);
        momentTv = (TextView) this.findViewById(R.id.momentTv);
        settingTv = (TextView) this.findViewById(R.id.settingTv);
        tablineIv = (ImageView) this.findViewById(R.id.iv_tabline);
        viewPager = (ViewPager) this.findViewById(R.id.viewpager);
    }

    /**
     * 初始化ViewPager和设置监听器
     */
    private void init() {
        mainFg = new MainFragment();
        momentFg = new MomentFragment();
        settingFg = new SettingFragment();
        //将三个页面添加到容器里面
        mFragmentList.add(mainFg);
        mFragmentList.add(momentFg);
        mFragmentList.add(settingFg);

        //重写一个FragmentAdapter继承FragmentPagerAdapter，需要FragmentManager和存放页面的容器过去
        mFragmentAdapter = new FragmentAdapter(this.getSupportFragmentManager(), mFragmentList);
        //ViewPager绑定监听器
        viewPager.setAdapter(mFragmentAdapter);
        //ViewPager设置默认当前的项
        viewPager.setCurrentItem(0);
        //ViewPager设置监听器，需要重写onPageScrollStateChanged，onPageScrolled，onPageSelected三个方法
        viewPager.addOnPageChangeListener(new OnPageChangeListener() {

        /**
         * state滑动中的状态 有三种状态（0，1，2） 1：正在滑动 2：滑动完毕 0：什么都没做。
         * 三个方法的执行顺序为：用手指拖动翻页时，最先执行一遍onPageScrollStateChanged（1），
         * 然后不断执行onPageScrolled，放手指的时候，直接立即执行一次onPageScrollStateChanged（2），
         * 然后立即执行一次onPageSelected，然后再不断执行onPageScrolled，
         * 最后执行一次onPageScrollStateChanged（0）。
         */

        /**
         * state滑动中的状态 有三种状态（0，1，2） 1：正在滑动 2：滑动完毕 0：什么都没做。
         */
        @Override
        public void onPageScrollStateChanged(int state) {
            Log.i(&amp;quot;PageScroll：&amp;quot;, &amp;quot;onPageScrollStateChanged&amp;quot; + &amp;quot;:&amp;quot; + state);
        }

        /**
         * position :当前页面，及你点击滑动的页面 offset:当前页面偏移的百分比
         * offsetPixels:当前页面偏移的像素位置
         */
        @Override
        public void onPageScrolled(int position, float offset,
                                   int offsetPixels) {
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) tablineIv.getLayoutParams();
            Log.i(&amp;quot;mOffset&amp;quot;, &amp;quot;offset:&amp;quot; + offset + &amp;quot;,position:&amp;quot; + position);
            /**
              * 利用currentIndex(当前所在页面)和position(下一个页面)以及offset来
              * 设置mTabLineIv的左边距 滑动场景：
                 * 记3个页面,
                 * 从左到右分别为0,1,2
                 * 0-&amp;gt;1; 1-&amp;gt;2; 2-&amp;gt;1; 1-&amp;gt;0
                 */
                if (currentIndex == 0 &amp;amp;&amp;amp; position == 0)// 0-&amp;gt;1
                {
                    lp.leftMargin = (int) (offset * (screenWidth * 1.0 / 3) +     currentIndex
                            * (screenWidth / 3));

                } else if (currentIndex == 1 &amp;amp;&amp;amp; position == 0) // 1-&amp;gt;0
                {
                    lp.leftMargin = (int) (-(1 - offset)
                            * (screenWidth * 1.0 / 3) + currentIndex
                            * (screenWidth / 3));

                } else if (currentIndex == 1 &amp;amp;&amp;amp; position == 1) // 1-&amp;gt;2
                {
                    lp.leftMargin = (int) (offset * (screenWidth * 1.0 / 3) +     currentIndex
                            * (screenWidth / 3));
                } else if (currentIndex == 2 &amp;amp;&amp;amp; position == 1) // 2-&amp;gt;1
                {
                       lp.leftMargin = (int) (-(1 - offset)
                            * (screenWidth * 1.0 / 3) + currentIndex
                            * (screenWidth / 3));
                }
                tablineIv.setLayoutParams(lp);
            }

            /**
             * 将当前选择的页面的标题设置字体颜色为蓝色
             */
            @Override
            public void onPageSelected(int position) {
                Log.i(&amp;quot;PageScroll：&amp;quot;, &amp;quot;onPageSelected&amp;quot; + &amp;quot;:&amp;quot; + position);
                resetTextView();
                switch (position) {
                    case 0:
                        mainTv.setTextColor(Color.BLUE);
                        break;
                    case 1:
                        momentTv.setTextColor(Color.BLUE);
                        break;
                    case 2:
                        settingTv.setTextColor(Color.BLUE);
                        break;
                }
                currentIndex = position;
            }
        });

    }

    /**
     * 设置滑动条的宽度为屏幕的1/3(根据Tab的个数而定)
     */
    private void initTabLineWidth() {
           DisplayMetrics dpMetrics = new DisplayMetrics();
        getWindow().getWindowManager().getDefaultDisplay().getMetrics(dpMetrics);
        screenWidth = dpMetrics.widthPixels;
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParam    tablineIv.getLayoutParams();
        lp.width = screenWidth / 3;
        tablineIv.setLayoutParams(lp);
    }

    /**
     * 重置颜色
     */
    private void resetTextView() {
        mainTv.setTextColor(Color.BLACK);
        momentTv.setTextColor(Color.BLACK);
        settingTv.setTextColor(Color.BLACK);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;FragmentAdapter.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.example.ryan.viewpagerdemo;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;

import java.util.ArrayList;
import java.util.List;

public class FragmentAdapter extends FragmentPagerAdapter {

    List&amp;lt;Fragment&amp;gt; fragmentList = new ArrayList&amp;lt;Fragment&amp;gt;();
    public FragmentAdapter(FragmentManager fm,List&amp;lt;Fragment&amp;gt; fragmentList) {
        super(fm);
        this.fragmentList = fragmentList;
    }

    @Override
    public Fragment getItem(int position) {
        return fragmentList.get(position);
    }

    @Override
    public int getCount() {
        return fragmentList.size();
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;源码下载&quot;&gt;&lt;a href=&quot;#源码下载&quot; class=&quot;headerlink&quot; title=&quot;源码下载&quot;&gt;&lt;/a&gt;源码下载&lt;/h2&gt;&lt;p&gt;ps：此Demo是使用Android Studio编写的，请使用AS打开。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://download.csdn.net/detail/ljcitworld/9474994&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://download.csdn.net/detail/ljcitworld/9474994&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/ryanlijianchang/ViewPagerDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ryanlijianchang/ViewPagerDemo&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：最近在项目开发中使用到了ViewPager，结合自己几天下来的学习，总结一下ViewPager的使用方法以及实现过程。&lt;/p&gt;
&lt;h2 id=&quot;实例效果&quot;&gt;&lt;a href=&quot;#实例效果&quot; class=&quot;headerlink&quot; title=&quot;实例效果&quot;&gt;&lt;/a&gt;实例效果&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-HowToUseVP-show.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android学习" scheme="lijianchang.xyz/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ViewPager" scheme="lijianchang.xyz/tags/ViewPager/"/>
    
  </entry>
  
  <entry>
    <title>写给大三的自己</title>
    <link href="lijianchang.xyz/2016/05/12/%E5%86%99%E7%BB%99%E5%A4%A7%E4%B8%89%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <id>lijianchang.xyz/2016/05/12/写给大三的自己/</id>
    <published>2016-05-12T14:10:54.641Z</published>
    <updated>2016-05-12T15:23:43.438Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;不动笔则已，一动笔发现自己已经三年大学都没有写过东西。呵，多么讽刺！因为自己曾经也是有过作家梦的，然而伴随着工科男的三年生活，渐渐丢失了自己最初的梦。从去年开始，自己就开始记录自己的专业知识，但是发现其实自己的生活还是一团糟，所以现在沉思，就算再忙，也要思考自己走过的路，也要学会沉淀自己的生活。&lt;/p&gt;
&lt;h3 id=&quot;实习&quot;&gt;&lt;a href=&quot;#实习&quot; class=&quot;headerlink&quot; title=&quot;实习&quot;&gt;&lt;/a&gt;实习&lt;/h3&gt;&lt;p&gt;伴随着五月份的到来，自己的大三生活也将进入倒计时，而自己也开始焦虑起来。焦虑自己身边的朋友都找到了不错的实习，焦虑自己仍然还没有拿到offer，连小公司也没有。开学初，错过了腾讯，百度，阿里巴巴，金山，优酷等等这些公司之后，自己也是放下自己的身段，去尝试投一些小公司。先后也面过五六个公司了，自己比较有印象的就是&lt;code&gt;广州逸信科技&lt;/code&gt;，&lt;code&gt;凯通科技&lt;/code&gt;，&lt;code&gt;CVTE&lt;/code&gt;这些公司自己感觉收获都挺多的，而且自己面试的时候感觉也是比较良好，但是自己最后还是没有拿到offer。现在回想起来，我想很大原因就是&lt;strong&gt;过于自信&lt;/strong&gt;，&lt;strong&gt;对自己定位不够&lt;/strong&gt;。因为自己一直是把自己放置在很高的位置，但是自己认真想起来自己还是很空， 掌握的东西真的还很少，所以接下来要好好总结。虽然心情还是很down，但是如果连这点苦都受不了，还怎么走向大海和星辰？&lt;/p&gt;
&lt;h3 id=&quot;朋友&quot;&gt;&lt;a href=&quot;#朋友&quot; class=&quot;headerlink&quot; title=&quot;朋友&quot;&gt;&lt;/a&gt;朋友&lt;/h3&gt;&lt;p&gt;大学三年，可以说没交到几个知心朋友，有我把他们真心对待的，但是我不确定我在他们心里是不是同样这么想。跟一个朋友最近也是没什么交流，因为我很讨厌他混着一些经常玩游戏的人，我又在忙着实习，哎，友谊真是很难把握的一个东西，但是想想自己三年来跟他一起做过的事情还是很多的，所以自己也不要就此丢失了这份友谊吧。不过我很感谢两个人，耀叔和靓妹，其实友情就是经得起岁月和时间的摧残，但是依然互相保存在自己的心理。而且跟他们在一起的时候自己是非常放松的，上周自己面试cvte之后，自己也是找了他们high了一天，谢谢他们在最失意的时候陪着自己。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;篮球兄弟&quot;&gt;&lt;a href=&quot;#篮球兄弟&quot; class=&quot;headerlink&quot; title=&quot;篮球兄弟&quot;&gt;&lt;/a&gt;篮球兄弟&lt;/h3&gt;&lt;p&gt;认真数数自己这一个月，真的没打几次球，因为自己都在忙着实习和做项目、复习，所以都没什么心情去打球，但是自己还是很感谢广工封开球队的人，虽然自己不是经常跟他们打球，但是依然每次打球都很开心，因为跟着一群同声同气的人真是很轻松，打球时也可以丢掉自己平时沉重的盔甲。今天是我们第二次去跟污水厂的员工打球，打到第二个加时输了，虽然这样，但是在场上跑动的时候，真是把所有的烦恼都丢在身后。我想这次打完之后我们也很难有机会真正地在一起打球了，毕竟我们都大三了，都要为自己的未来拼搏了，但是希望我们都不要丢失了自己一直的篮球梦，不能为命运折服自己仅剩的一点兴趣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;孔慧师姐&quot;&gt;&lt;a href=&quot;#孔慧师姐&quot; class=&quot;headerlink&quot; title=&quot;孔慧师姐&quot;&gt;&lt;/a&gt;孔慧师姐&lt;/h3&gt;&lt;p&gt;其实自己一直很想认真感谢一些孔慧师姐，她是我踏进校园认识的第一位女生，当时我刚到学校，人生路不熟，然后她就打到了我的电话，嘘寒问暖的，超级温暖。当时真的把她当做自己的大姐姐，遇到了问题都是问她，记得当时做班干部什么的都是问她，感觉自己的心超级脆弱，也正是她给我的建议，让我轻松地度过了大学的适应期。而今年也是她的毕业季，真心希望她未来可以事业爱情双丰收，我坚信好人一生平安，哈哈，谢谢你，孔慧师姐！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan7.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h3&gt;&lt;p&gt;人生或许就是很多的不完美组成，正是这些不完美，才组成了我们精彩的人生；&lt;/p&gt;
&lt;p&gt;人生或许会遭遇到很多的挫败，正是这些挫败，才为我们日后的成功打下基础！&lt;/p&gt;
&lt;p&gt;—-献给所有和我遇到一样问题的人，共勉！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WritingToDaSan8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="lijianchang.xyz/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感想" scheme="lijianchang.xyz/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发者必备技能之-点九图的制作</title>
    <link href="lijianchang.xyz/2016/03/17/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%80%85%E6%8A%80%E8%83%BD%E4%B9%8B-%E7%82%B9%E4%B9%9D%E5%9B%BE%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <id>lijianchang.xyz/2016/03/17/安卓开发者技能之-点九图的制作/</id>
    <published>2016-03-17T13:37:26.000Z</published>
    <updated>2016-08-30T03:34:25.787Z</updated>
    
    <content type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很多安卓开发者觉得UI制作都是美工的事情，自己只需要完成控件的摆放和功能的实现。但是很多时候，在我们自己写一些小应用或者小Demo的时候，并不会有个美工在我们身边，而点九图之于我们安卓开发者来说再常见不过了，所以这个技能我们掌握了也是非常实用的。以下博文只是带大家入门使用点九图，不敢在美工设计师面前班门弄斧，大神请直接略过。&lt;/p&gt;
&lt;h2 id=&quot;点九图&quot;&gt;&lt;a href=&quot;#点九图&quot; class=&quot;headerlink&quot; title=&quot;点九图&quot;&gt;&lt;/a&gt;点九图&lt;/h2&gt;&lt;p&gt;随着智能手机的发展,我们的应用需要适应不同屏幕尺寸的手机，同一幅界面会在随着手机(或平板电脑)中的方向传感器的参数不同而改变显示的方向,在界面改变方向后,界面上的图形会因为长宽的变化而产生拉伸,造成图形的失真变形。&lt;/p&gt;
&lt;p&gt;而点九（即.9），是andriod平台的应用软件开发里的一种特殊的图片形式，文件扩展名为：.9.png，正是为了解决我们的图片在不同尺寸屏幕上显示失真而应运而生的一种格式。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;center&gt;普通拉伸和点九拉伸效果对比&lt;/center&gt;

&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;经过对比，很明显，使用点九后，仍能保留图像的渐变质感，和圆角的精细度。&lt;/p&gt;
&lt;p&gt;所以，使用.9图的意义就是为了从自己.png格式的图片中选画出四条线，这四条线相互交错构成了九个部分(这就是叫做点九图的原因)，然后我们的内容只能在其中重复的那个区域显示，而我们的图片在拉伸过程中只有显示内容的部分被拉伸，从而使得我们图片的边缘部分得到了很好的保真效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Android Studio (Android Studio自带制作点九图功能)&lt;/li&gt;
&lt;li&gt;Draw9path(PC端可以直接&lt;a href=&quot;vdisk.weibo.com/s/t7XO23ZcP4wW&quot;&gt;下载&lt;/a&gt;使用)&lt;/li&gt;
&lt;li&gt;NinePng(一个安卓应用，使用简单，去手机商店直接搜索就有了)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;制作-9图&quot;&gt;&lt;a href=&quot;#制作-9图&quot; class=&quot;headerlink&quot; title=&quot;制作.9图&quot;&gt;&lt;/a&gt;制作.9图&lt;/h2&gt;&lt;h3 id=&quot;在Android-Studio下制作&quot;&gt;&lt;a href=&quot;#在Android-Studio下制作&quot; class=&quot;headerlink&quot; title=&quot;在Android Studio下制作&quot;&gt;&lt;/a&gt;在Android Studio下制作&lt;/h3&gt;&lt;p&gt;1.打开AS，将你要制作点九图的.png图片放到工程目录的drawable文件夹下（例如我准备了一张word.png），右键，选择 Create 9-Patch file&lt;br&gt;  &lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.然后会产生一个同名的以.9.png为后缀的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.双击打开 **.9.png图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.我们可以看到有四条线，就是我们上面所说到的构成九个区域的四条线，那么我们就可以直接通过拖拉着四条线选择我们所需要的区域即可，完成后在图片可以看到左和上有两条黑线，而把鼠标放到中间，就可以看到我们图片实际拉伸的区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-6_.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;5.拉伸右边的预览框，可以看到我们的.9图在不同拉伸情况下的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;在Draw9path下制作&quot;&gt;&lt;a href=&quot;#在Draw9path下制作&quot; class=&quot;headerlink&quot; title=&quot;在Draw9path下制作&quot;&gt;&lt;/a&gt;在Draw9path下制作&lt;/h3&gt;&lt;p&gt;如果你不是安卓开发者，只是一个美工人员，那么Draw9Path是一个不错的选择。&lt;/p&gt;
&lt;p&gt;1.安装完成Draw9Path之后打开 draw9patch.bat,然后按 Ctrl+O 打开一张们需要制作的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.将鼠标放到中心区域，可以看到图片已经被打上马赛克，但是四周边缘留下空白的地方，这些地方就是让我们划线用的。&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.然后我们按住鼠标，在我们需要划线的区域划线即可(按住shift+鼠标左键为删除点，不支持Ctrl+Z撤销功能)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-10.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击右上角Show bad patches来查看我们画的线是否对齐。&lt;/li&gt;
&lt;li&gt;点击下边的Show Content显示拉伸的后的内容区域。&lt;/li&gt;
&lt;li&gt;点击下边的Show Patches显示当前图片的内容区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.按Ctrl + S保存图片。&lt;/p&gt;
&lt;h3 id=&quot;在NinePng下制作&quot;&gt;&lt;a href=&quot;#在NinePng下制作&quot; class=&quot;headerlink&quot; title=&quot;在NinePng下制作&quot;&gt;&lt;/a&gt;在NinePng下制作&lt;/h3&gt;&lt;p&gt;网上已经有详细教程，此处就不给具体的教程了。&lt;/p&gt;
&lt;p&gt;详看： &lt;a href=&quot;http://www.zcool.com.cn/article/ZMTgzODUy.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于点九图的介绍及其制作&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行效果&quot;&gt;&lt;a href=&quot;#运行效果&quot; class=&quot;headerlink&quot; title=&quot;运行效果&quot;&gt;&lt;/a&gt;运行效果&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-17.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-18.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-19.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/qianxudetianxia/archive/2011/04/17/2017591.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;App自适应draw9patch不失真背景&lt;/a&gt; -by 谦虚的天下&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zcool.com.cn/article/ZMTgzODUy.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于点九图的介绍及其制作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很多安卓开发者觉得UI制作都是美工的事情，自己只需要完成控件的摆放和功能的实现。但是很多时候，在我们自己写一些小应用或者小Demo的时候，并不会有个美工在我们身边，而点九图之于我们安卓开发者来说再常见不过了，所以这个技能我们掌握了也是非常实用的。以下博文只是带大家入门使用点九图，不敢在美工设计师面前班门弄斧，大神请直接略过。&lt;/p&gt;
&lt;h2 id=&quot;点九图&quot;&gt;&lt;a href=&quot;#点九图&quot; class=&quot;headerlink&quot; title=&quot;点九图&quot;&gt;&lt;/a&gt;点九图&lt;/h2&gt;&lt;p&gt;随着智能手机的发展,我们的应用需要适应不同屏幕尺寸的手机，同一幅界面会在随着手机(或平板电脑)中的方向传感器的参数不同而改变显示的方向,在界面改变方向后,界面上的图形会因为长宽的变化而产生拉伸,造成图形的失真变形。&lt;/p&gt;
&lt;p&gt;而点九（即.9），是andriod平台的应用软件开发里的一种特殊的图片形式，文件扩展名为：.9.png，正是为了解决我们的图片在不同尺寸屏幕上显示失真而应运而生的一种格式。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/post-dianjiu-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;

&lt;center&gt;普通拉伸和点九拉伸效果对比&lt;/center&gt;
    
    </summary>
    
      <category term="Android" scheme="lijianchang.xyz/categories/Android/"/>
    
    
      <category term="点九图" scheme="lijianchang.xyz/tags/%E7%82%B9%E4%B9%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>小白独立搭建博客-Github-Pages和Hexo简明教程</title>
    <link href="lijianchang.xyz/2016/03/16/%E5%B0%8F%E7%99%BD%E7%8B%AC%E7%AB%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-Github-Pages%E5%92%8CHexo%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>lijianchang.xyz/2016/03/16/小白独立搭建博客-Github-Pages和Hexo简明教程/</id>
    <published>2016-03-15T17:41:40.000Z</published>
    <updated>2016-05-12T02:44:59.699Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-GithubAndHexoyhbg.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先欢迎各位来参观我的博客：&lt;a href=&quot;http://lijianchang.xyz/&quot;&gt;Ryane’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/ryanlijianchang/ryanlijianchang.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ryanlijianchang/ryanlijianchang.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这是一篇有关如何使用Github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，域名注册，以及域名的绑定，还有我在搭建自己博客过程中所遇到的各种困难。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我是一名安卓入门开发者，但，我只是&lt;strong&gt;入门&lt;/strong&gt;！而且我对网站开发以及前端的知识几乎是零基础，所以在自己刚接触这个东西的时候，我像很多人一样，都是上网找教程，但是要知道，&lt;strong&gt;那都是程序员的教程。&lt;/strong&gt;所以对于我这个网站技术小白来说，真是很难受，所以藉此机会写一篇让小白看得懂的教程。如果你是一个小白而且又想做自己的博客，可以，请跟着我的脚步，我会带你真真正正做一个属于你自己的博客。&lt;/p&gt;
&lt;p&gt;如果你还不知道你为什么要做一个博客，推荐你看：&lt;a href=&quot;http://www.cnblogs.com/jhzhu/p/3893297.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《我为什么写博客》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;入门门槛&quot;&gt;&lt;a href=&quot;#入门门槛&quot; class=&quot;headerlink&quot; title=&quot;入门门槛&quot;&gt;&lt;/a&gt;入门门槛&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;必须耐得住折腾。&lt;/li&gt;
&lt;li&gt;刻苦的学习精神和耐心。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;关于Github&quot;&gt;&lt;a href=&quot;#关于Github&quot; class=&quot;headerlink&quot; title=&quot;关于Github&quot;&gt;&lt;/a&gt;关于Github&lt;/h2&gt;&lt;center&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/github-jxw.jpg&quot; alt=&quot;&quot;&gt;&lt;/center&gt;


&lt;h3 id=&quot;一、Github的优点&quot;&gt;&lt;a href=&quot;#一、Github的优点&quot; class=&quot;headerlink&quot; title=&quot;一、Github的优点&quot;&gt;&lt;/a&gt;一、Github的优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。&lt;/li&gt;
&lt;li&gt;GitHub可以免费使用，并且快速稳定。&lt;/li&gt;
&lt;li&gt;Github上面的世界很精彩，用久了你的眼界会开阔很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二、什么是Github-Pages&quot;&gt;&lt;a href=&quot;#二、什么是Github-Pages&quot; class=&quot;headerlink&quot; title=&quot;二、什么是Github Pages&quot;&gt;&lt;/a&gt;二、什么是Github Pages&lt;/h3&gt;&lt;p&gt;Github Pages可以被认为是用户编写的、托管在github上的静态网页。&lt;/p&gt;
&lt;h3 id=&quot;三、为什么要使用Github-Pages&quot;&gt;&lt;a href=&quot;#三、为什么要使用Github-Pages&quot; class=&quot;headerlink&quot; title=&quot;三、为什么要使用Github Pages&quot;&gt;&lt;/a&gt;三、为什么要使用Github Pages&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以绑定你的域名(但暂时貌似只能绑定一个)。&lt;/li&gt;
&lt;li&gt;简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装Node-js&quot;&gt;&lt;a href=&quot;#安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;安装Node.js&quot;&gt;&lt;/a&gt;安装Node.js&lt;/h2&gt;&lt;p&gt;在 Windows 环境下安装 Node.js 非常简单，仅须到&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网下载&lt;/a&gt;安装文件并执行即可完成安装。&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/image-nodeJs-dl.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;像我的是Windows 64位，直接下载安装，不需要配置环境变量。&lt;/p&gt;
&lt;h2 id=&quot;安装Git&quot;&gt;&lt;a href=&quot;#安装Git&quot; class=&quot;headerlink&quot; title=&quot;安装Git&quot;&gt;&lt;/a&gt;安装Git&lt;/h2&gt;&lt;p&gt;下载 msysgit 并执行即可完成安装。(上官网要翻墙，如果你的是64位，可以&lt;a href=&quot;http://pan.baidu.com/s/1i4xAM9Z&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击此处&lt;/a&gt;下载)&lt;/p&gt;
&lt;p&gt;怎么打开Git？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/gitbash-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/gitbash-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装教程：&lt;a href=&quot;http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如何在windows下安装GIT&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git入门教程：&lt;a href=&quot;http://git.oschina.net/progit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pro Git（中文版）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git基本操作：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/git.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h2&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;/p&gt;
&lt;h3 id=&quot;一、Hexo安装&quot;&gt;&lt;a href=&quot;#一、Hexo安装&quot; class=&quot;headerlink&quot; title=&quot;一、Hexo安装&quot;&gt;&lt;/a&gt;一、Hexo安装&lt;/h3&gt;&lt;p&gt;桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-cli -g
npm install hexo --save
#如果命令无法运行，可以尝试更换taobao的npm源
npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二、Hexo初始化配置&quot;&gt;&lt;a href=&quot;#二、Hexo初始化配置&quot; class=&quot;headerlink&quot; title=&quot;二、Hexo初始化配置&quot;&gt;&lt;/a&gt;二、Hexo初始化配置&lt;/h3&gt;&lt;h4 id=&quot;创建Hexo文件夹&quot;&gt;&lt;a href=&quot;#创建Hexo文件夹&quot; class=&quot;headerlink&quot; title=&quot;创建Hexo文件夹&quot;&gt;&lt;/a&gt;创建Hexo文件夹&lt;/h4&gt;&lt;p&gt;安装完成后，根据自己喜好建立目录（如F:\Blog\Hexo），直接进入F:\Blog\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo init
$ npm install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下：&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/hexo-content.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;安装Hexo插件&quot;&gt;&lt;a href=&quot;#安装Hexo插件&quot; class=&quot;headerlink&quot; title=&quot;安装Hexo插件&quot;&gt;&lt;/a&gt;安装Hexo插件&lt;/h4&gt;&lt;p&gt;如果想不出错，就将下面的插件都安装完。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-generator-index --save
npm install hexo-generator-archive --save
npm install hexo-generator-category --save
npm install hexo-generator-tag --save
npm install hexo-server --save
npm install hexo-deployer-git --save
npm install hexo-deployer-heroku --save
npm install hexo-deployer-rsync --save
npm install hexo-deployer-openshift --save
npm install hexo-renderer-marked@0.2 --save
npm install hexo-renderer-stylus@0.2 --save
npm install hexo-generator-feed@1 --save
npm install hexo-generator-sitemap@1 --save
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;本地查看效果&quot;&gt;&lt;a href=&quot;#本地查看效果&quot; class=&quot;headerlink&quot; title=&quot;本地查看效果&quot;&gt;&lt;/a&gt;本地查看效果&lt;/h4&gt;&lt;p&gt;执行下面语句，执行完即可登录localhost:4000查看效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo generate
hexo server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;登录localhost:4000，即可看到本地的效果如下：&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/imagelocalhost.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;将博客部署到Github-Pages上&quot;&gt;&lt;a href=&quot;#将博客部署到Github-Pages上&quot; class=&quot;headerlink&quot; title=&quot;将博客部署到Github Pages上&quot;&gt;&lt;/a&gt;将博客部署到Github Pages上&lt;/h2&gt;&lt;p&gt;那么现在本地的博客已经搭建起来了，但是我们只可以通过本地连接查看我们的博客。那么我们现在需要做的就是把本地的博客发布到服务器上，让别人也可以连接我们的博客，而Github Pages就帮我完成了这件事情。但是Github Pages的代码就是寄存在Github上面的。那么接下来我们需要在Github上面创建一个新的项目。&lt;/p&gt;
&lt;h3 id=&quot;一、注册Github账户&quot;&gt;&lt;a href=&quot;#一、注册Github账户&quot; class=&quot;headerlink&quot; title=&quot;一、注册Github账户&quot;&gt;&lt;/a&gt;一、注册Github账户&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;访问&lt;a href=&quot;访问：http://www.github.com/&quot;&gt;Github首页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;点击右上角的&lt;a href=&quot;https://github.com/join?source=header-home&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Sign Up&lt;/a&gt;，注册自己的账户&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;二、创建项目代码库&quot;&gt;&lt;a href=&quot;#二、创建项目代码库&quot; class=&quot;headerlink&quot; title=&quot;二、创建项目代码库&quot;&gt;&lt;/a&gt;二、创建项目代码库&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击&lt;a href=&quot;https://github.com/new&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;New repository&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;创建要点如下：&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/how-to-create-reposity.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;三、配置SSH密钥&quot;&gt;&lt;a href=&quot;#三、配置SSH密钥&quot; class=&quot;headerlink&quot; title=&quot;三、配置SSH密钥&quot;&gt;&lt;/a&gt;三、配置SSH密钥&lt;/h3&gt;&lt;p&gt;配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：&lt;/p&gt;
&lt;h4 id=&quot;第一步、看看是否存在SSH密钥-keys&quot;&gt;&lt;a href=&quot;#第一步、看看是否存在SSH密钥-keys&quot; class=&quot;headerlink&quot; title=&quot;第一步、看看是否存在SSH密钥(keys)&quot;&gt;&lt;/a&gt;第一步、看看是否存在SSH密钥(keys)&lt;/h4&gt;&lt;p&gt;首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/. ssh 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查你本机用户home目录下是否存在.ssh目录&lt;/p&gt;
&lt;p&gt;如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。&lt;/p&gt;
&lt;h4 id=&quot;第二步、创建一对新的SSH密钥-keys&quot;&gt;&lt;a href=&quot;#第二步、创建一对新的SSH密钥-keys&quot; class=&quot;headerlink&quot; title=&quot;第二步、创建一对新的SSH密钥(keys)&quot;&gt;&lt;/a&gt;第二步、创建一对新的SSH密钥(keys)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;$ssh-keygen -t rsa -C &amp;quot;your_email@example.com&amp;quot;
#这将按照你提供的邮箱地址，创建一对密钥
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa&lt;/p&gt;
&lt;p&gt;接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入完成之后，屏幕会显示如下信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Your identification has been saved in /c/Users/you/.ssh/id_rsa.
Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;第三步、在GitHub账户中添加你的公钥&quot;&gt;&lt;a href=&quot;#第三步、在GitHub账户中添加你的公钥&quot; class=&quot;headerlink&quot; title=&quot;第三步、在GitHub账户中添加你的公钥&quot;&gt;&lt;/a&gt;第三步、在GitHub账户中添加你的公钥&lt;/h4&gt;&lt;p&gt;运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clip &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;登陆GitHub,进入你的Account Settings.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/SSH-github-setting.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.选择SSH Keys&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/SSH-github-setting-SSH.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.粘贴密钥，添加即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/SSH-github-SSH-OK.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第四步、测试&quot;&gt;&lt;a href=&quot;#第四步、测试&quot; class=&quot;headerlink&quot; title=&quot;第四步、测试&quot;&gt;&lt;/a&gt;第四步、测试&lt;/h4&gt;&lt;p&gt;可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是下面的反馈：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The authenticity of host &amp;apos;github.com (207.97.227.239)&amp;apos; can&amp;apos;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不要紧张，输入yes就好，然后会看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hi cnfeat! You&amp;apos;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;第五步、设置用户信息&quot;&gt;&lt;a href=&quot;#第五步、设置用户信息&quot; class=&quot;headerlink&quot; title=&quot;第五步、设置用户信息&quot;&gt;&lt;/a&gt;第五步、设置用户信息&lt;/h4&gt;&lt;p&gt;现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。&lt;br&gt;Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git config --global user.name &amp;quot;cnfeat&amp;quot;//用户名
$ git config --global user.email  &amp;quot;cnfeat@gmail.com&amp;quot;//填写自己的邮箱
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;第六步、SSH-Key配置成功&quot;&gt;&lt;a href=&quot;#第六步、SSH-Key配置成功&quot; class=&quot;headerlink&quot; title=&quot;第六步、SSH Key配置成功&quot;&gt;&lt;/a&gt;第六步、SSH Key配置成功&lt;/h4&gt;&lt;p&gt;本机已成功连接到github。&lt;br&gt;如有问题，请参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/generating-an-ssh-key/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Help - Generating SSH Keys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/error-permission-denied-publickey/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Error: Permission denied (publickey)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;四、将本地的Hexo文件更新到Github的库中&quot;&gt;&lt;a href=&quot;#四、将本地的Hexo文件更新到Github的库中&quot; class=&quot;headerlink&quot; title=&quot;四、将本地的Hexo文件更新到Github的库中&quot;&gt;&lt;/a&gt;四、将本地的Hexo文件更新到Github的库中&lt;/h3&gt;&lt;h4 id=&quot;第一步、登录Github打开自己的项目-username-github-io&quot;&gt;&lt;a href=&quot;#第一步、登录Github打开自己的项目-username-github-io&quot; class=&quot;headerlink&quot; title=&quot;第一步、登录Github打开自己的项目 username.github.io&quot;&gt;&lt;/a&gt;第一步、登录Github打开自己的项目 username.github.io&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/getHTTPS-teach_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第二步、打开之后，点击HTTPS，选择HTTPS类型地址&quot;&gt;&lt;a href=&quot;#第二步、打开之后，点击HTTPS，选择HTTPS类型地址&quot; class=&quot;headerlink&quot; title=&quot;第二步、打开之后，点击HTTPS，选择HTTPS类型地址&quot;&gt;&lt;/a&gt;第二步、打开之后，点击HTTPS，选择HTTPS类型地址&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/getHTTPS-teach_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第三步、复制地址&quot;&gt;&lt;a href=&quot;#第三步、复制地址&quot; class=&quot;headerlink&quot; title=&quot;第三步、复制地址&quot;&gt;&lt;/a&gt;第三步、复制地址&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/getHTTPS-teach_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第四步、打开你一开始创建的Hexo文件夹（如F-Blog-Hexo），用记事本打开刚文件夹下的-config-yml文件&quot;&gt;&lt;a href=&quot;#第四步、打开你一开始创建的Hexo文件夹（如F-Blog-Hexo），用记事本打开刚文件夹下的-config-yml文件&quot; class=&quot;headerlink&quot; title=&quot;第四步、打开你一开始创建的Hexo文件夹（如F:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml文件&quot;&gt;&lt;/a&gt;第四步、打开你一开始创建的Hexo文件夹（如F:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml文件&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/getHTTPS-teach_4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第五步、在配置文件里作如下修改，保存&quot;&gt;&lt;a href=&quot;#第五步、在配置文件里作如下修改，保存&quot; class=&quot;headerlink&quot; title=&quot;第五步、在配置文件里作如下修改，保存&quot;&gt;&lt;/a&gt;第五步、在配置文件里作如下修改，保存&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/getHTTPS-teach_5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第六步、在Hexo文件夹下执行：&quot;&gt;&lt;a href=&quot;#第六步、在Hexo文件夹下执行：&quot; class=&quot;headerlink&quot; title=&quot;第六步、在Hexo文件夹下执行：&quot;&gt;&lt;/a&gt;第六步、在Hexo文件夹下执行：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;hexo g
hexo d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者直接执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo g -d
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。&lt;/p&gt;
&lt;h4 id=&quot;第七步、在浏览器上输入自己的主页地址&quot;&gt;&lt;a href=&quot;#第七步、在浏览器上输入自己的主页地址&quot; class=&quot;headerlink&quot; title=&quot;第七步、在浏览器上输入自己的主页地址&quot;&gt;&lt;/a&gt;第七步、在浏览器上输入自己的主页地址&lt;/h4&gt;&lt;p&gt;在浏览器上输入即可看到我们自己的博客，别人电脑输入也可以哦。&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/blog-main.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;美化自己博客&quot;&gt;&lt;a href=&quot;#美化自己博客&quot; class=&quot;headerlink&quot; title=&quot;美化自己博客&quot;&gt;&lt;/a&gt;美化自己博客&lt;/h2&gt;&lt;p&gt;那么现在我们的博客已经挂在了服务器上面，别人已经可以通过网址来登陆我们的博客了，但是我们这时就有了新的需求，就是自己的博客并不好看，那怎么办的？这很简单，要知道很多前端开发者在Hexo框架下开发了很多的主题给我们使用，我们只需要把他们的主题克隆过来，然后通过修改配置文件即可达到我们所需要的效果。&lt;/p&gt;
&lt;p&gt;那么我们应该怎么修改呢？&lt;/p&gt;
&lt;h3 id=&quot;一、进入Hexo的官网主题专栏&quot;&gt;&lt;a href=&quot;#一、进入Hexo的官网主题专栏&quot; class=&quot;headerlink&quot; title=&quot;一、进入Hexo的官网主题专栏&quot;&gt;&lt;/a&gt;一、进入&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo的官网主题专栏&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/themes.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、挑选我们喜欢的主题&quot;&gt;&lt;a href=&quot;#二、挑选我们喜欢的主题&quot; class=&quot;headerlink&quot; title=&quot;二、挑选我们喜欢的主题&quot;&gt;&lt;/a&gt;二、挑选我们喜欢的主题&lt;/h3&gt;&lt;p&gt;可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/address.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、克隆主题&quot;&gt;&lt;a href=&quot;#三、克隆主题&quot; class=&quot;headerlink&quot; title=&quot;三、克隆主题&quot;&gt;&lt;/a&gt;三、克隆主题&lt;/h3&gt;&lt;p&gt;再打开Hexo文件夹下的themes目录（F:\Blog\hexo\themes），右键Git Bash，在命令行输入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载中，等待下载完成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/downloading.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四、修改Hexo配置文件&quot;&gt;&lt;a href=&quot;#四、修改Hexo配置文件&quot; class=&quot;headerlink&quot; title=&quot;四、修改Hexo配置文件&quot;&gt;&lt;/a&gt;四、修改Hexo配置文件&lt;/h3&gt;&lt;p&gt;下载完成后，打开Hexo文件夹下的配置文件&lt;code&gt;_config.yml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改参数为：&lt;code&gt;theme: hexo-theme-next&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;五、部署主题，本地查看效果&quot;&gt;&lt;a href=&quot;#五、部署主题，本地查看效果&quot; class=&quot;headerlink&quot; title=&quot;五、部署主题，本地查看效果&quot;&gt;&lt;/a&gt;五、部署主题，本地查看效果&lt;/h3&gt;&lt;p&gt;返回Hexo目录，右键Git Bash，输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo g
hexo s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开浏览器，输入 &lt;code&gt;http://localhost:4000/&lt;/code&gt; 即可看见我们的主题已经更换了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/new-theme.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;六、如果效果满意，将它部署到Github上&quot;&gt;&lt;a href=&quot;#六、如果效果满意，将它部署到Github上&quot; class=&quot;headerlink&quot; title=&quot;六、如果效果满意，将它部署到Github上&quot;&gt;&lt;/a&gt;六、如果效果满意，将它部署到Github上&lt;/h3&gt;&lt;p&gt;打开Hexo文件夹，右键Git Bash，输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo clean   (必须要，不然有时因为缓存问题，服务器更新不了主题)
hexo g -d
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;七、打开自己的主页，即可看到修改后的效果&quot;&gt;&lt;a href=&quot;#七、打开自己的主页，即可看到修改后的效果&quot; class=&quot;headerlink&quot; title=&quot;七、打开自己的主页，即可看到修改后的效果&quot;&gt;&lt;/a&gt;七、打开自己的主页，即可看到修改后的效果&lt;/h3&gt;&lt;p&gt;更多修改效果请查看对应主题的说明文档，&lt;a href=&quot;http://theme-next.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击此&lt;/a&gt;查看本主题(Next)对应的说明文档。&lt;/p&gt;
&lt;h2 id=&quot;在博客写文章&quot;&gt;&lt;a href=&quot;#在博客写文章&quot; class=&quot;headerlink&quot; title=&quot;在博客写文章&quot;&gt;&lt;/a&gt;在博客写文章&lt;/h2&gt;&lt;h3 id=&quot;一、用hexo发表新文章&quot;&gt;&lt;a href=&quot;#一、用hexo发表新文章&quot; class=&quot;headerlink&quot; title=&quot;一、用hexo发表新文章&quot;&gt;&lt;/a&gt;一、用hexo发表新文章&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;$ hexo n &amp;quot;文章标题&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 我的家 为文章标题，执行命令 &lt;code&gt;hexo n &amp;quot;我的家&amp;quot;&lt;/code&gt; 后，会在项目 \Hexo\source_posts 中生成 &lt;code&gt;我的家.md&lt;/code&gt;文件，用编辑器打开编写即可。&lt;/p&gt;
&lt;p&gt;当然，也可以直接在\Hexo\source_posts中新建一个md文件，我就是这么做的。&lt;br&gt;写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo g #生成
$ hexo d #部署 # 可与hexo g合并为 hexo d -g
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二、用Markdown写文章&quot;&gt;&lt;a href=&quot;#二、用Markdown写文章&quot; class=&quot;headerlink&quot; title=&quot;二、用Markdown写文章&quot;&gt;&lt;/a&gt;二、用Markdown写文章&lt;/h3&gt;&lt;p&gt;我们注意到在 \Hexo\source_posts 文件夹下存放着我们的文章，它们的格式都是以&lt;code&gt;.md&lt;/code&gt;格式结尾的，没错，Hexo也是支持Markdown语法的，所以当我们需要写具有格式化的文章时，我们可以使用支持Markdown语法的编辑器进行文章编译，然后保存文件到 \Hexo\source_posts 文件夹下即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/markdown.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;复制进去之后，只要执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ hexo d -g 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;推送到我们的Github仓库即可。&lt;/p&gt;
&lt;h4 id=&quot;那么什么是Markdown？&quot;&gt;&lt;a href=&quot;#那么什么是Markdown？&quot; class=&quot;headerlink&quot; title=&quot;那么什么是Markdown？&quot;&gt;&lt;/a&gt;那么什么是Markdown？&lt;/h4&gt;&lt;p&gt;Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。&lt;/p&gt;
&lt;h4 id=&quot;Markdown有什么优点？&quot;&gt;&lt;a href=&quot;#Markdown有什么优点？&quot; class=&quot;headerlink&quot; title=&quot;Markdown有什么优点？&quot;&gt;&lt;/a&gt;Markdown有什么优点？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;专注你的文字内容而不是排版样式。&lt;/li&gt;
&lt;li&gt;轻松的导出 HTML、PDF 和本身的 .md 文件。&lt;/li&gt;
&lt;li&gt;纯文本内容，兼容所有的文本编辑器与字处理软件。&lt;/li&gt;
&lt;li&gt;可读，直观。适合所有人的写作语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;我该用什么工具？&quot;&gt;&lt;a href=&quot;#我该用什么工具？&quot; class=&quot;headerlink&quot; title=&quot;我该用什么工具？&quot;&gt;&lt;/a&gt;我该用什么工具？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Windows下可以使用 MarkdownPad2。&lt;/li&gt;
&lt;li&gt;在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。&lt;/li&gt;
&lt;li&gt;Web 端上，我强烈推荐 简书 这款产品。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于Markdown的更多资料可以查看如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://sspai.com/25137&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;认识与入门 Markdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.douban.com/note/350126154/?type=like&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown入门指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;将自己的域名关联到Github-Pages上&quot;&gt;&lt;a href=&quot;#将自己的域名关联到Github-Pages上&quot; class=&quot;headerlink&quot; title=&quot;将自己的域名关联到Github Pages上&quot;&gt;&lt;/a&gt;将自己的域名关联到Github Pages上&lt;/h2&gt;&lt;p&gt;很多朋友创建了自己的博客之后会选择买一个属于自己的域名，然后将自己域名绑定到自己的Github Pages博客上，其实这也并不难，只要你有个域名。&lt;/p&gt;
&lt;h3 id=&quot;一、购买域名&quot;&gt;&lt;a href=&quot;#一、购买域名&quot; class=&quot;headerlink&quot; title=&quot;一、购买域名&quot;&gt;&lt;/a&gt;一、购买域名&lt;/h3&gt;&lt;p&gt;如果你不是很有钱，在&lt;a href=&quot;https://wanwang.aliyun.com/domain/?spm=5176.383338.1907008.1.LWIFhw&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里云&lt;/a&gt;上，你只要几块钱就可以买到一个域名。&lt;/p&gt;
&lt;p&gt;选择你喜欢的域名，然后购买即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/yuming.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、配置CNAME文件&quot;&gt;&lt;a href=&quot;#二、配置CNAME文件&quot; class=&quot;headerlink&quot; title=&quot;二、配置CNAME文件&quot;&gt;&lt;/a&gt;二、配置CNAME文件&lt;/h3&gt;&lt;p&gt;在 \hexo\source 文件夹下创建文件 CNAME  （新建记事本文件命名CNAME，然后打开）&lt;/p&gt;
&lt;p&gt;内容为你的域名，例如我的域名是：lijianchang.xyz&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/cname2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Hexo文件夹提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo g -d
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;三、修改DNS的DNS&quot;&gt;&lt;a href=&quot;#三、修改DNS的DNS&quot; class=&quot;headerlink&quot; title=&quot;三、修改DNS的DNS&quot;&gt;&lt;/a&gt;三、修改DNS的DNS&lt;/h3&gt;&lt;p&gt;1.如果你是在阿里云购买域名的话，请登录阿里云网站。打开个人中心，点击域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/domain_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.选择管理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/domain_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.修改DNS为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f1g1ns2.dnspod.net 
f1g1ns1.dnspod.net 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/domain_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;四、域名解析&quot;&gt;&lt;a href=&quot;#四、域名解析&quot; class=&quot;headerlink&quot; title=&quot;四、域名解析&quot;&gt;&lt;/a&gt;四、域名解析&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开&lt;a href=&quot;https://www.dnspod.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DNSPOD&lt;/a&gt;，注册一个账户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击添加域名，把你的域名添加进去，如无意外，添加完之后就是以下这个状态&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/domain_4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;此时点击添加记录，添加两个记录，一个主机记录为&lt;code&gt;@&lt;/code&gt;， 一个为&lt;code&gt;www&lt;/code&gt;，而记录值都是填同一个，填你的博客主页对应的ip，添加完后如下。&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/ip2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是如何获取ip值呢？打开运行，输入cmd，打开命令窗口输入 &lt;code&gt;ping 主页地址&lt;/code&gt; ， 红色部分即为你的ip值&lt;br&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/ip.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将IP输入过去即可。等待生效，最迟72小时生效。即可通过你的域名浏览你的博客主页。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;当你完成了你的博客之后，相信你的心情跟我刚做完的心情是一样的，即便很累，但是当自己的博客成型之后，自己还是有一个成就感的，那么完成后，以后的路还很长，真正想要自己博客能够积累人气，还得靠好的内容，所以认真写文章吧，相信你会受益于此的。&lt;/p&gt;
&lt;p&gt;如果大家有什么问题的话，可以在我留言板下留言，我看到评论时会第一时间回答大家。&lt;/p&gt;
&lt;h2 id=&quot;参考资料：&quot;&gt;&lt;a href=&quot;#参考资料：&quot; class=&quot;headerlink&quot; title=&quot;参考资料：&quot;&gt;&lt;/a&gt;参考资料：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown入门手册中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/1e402922ee32/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown–入门指南&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如何搭建一个独立博客——简明 Github Pages与 jekyll 教程&lt;/a&gt; by cnfeat&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/zhcncn/p/4097881.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo搭建Github静态博客&lt;/a&gt; by 金石开&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.xuanfengge.com/using-ssh-key-link-github-photo-tour.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用SSH密钥连接Github【图文教程】&lt;/a&gt; by 轩枫&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-GithubAndHexoyhbg.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="lijianchang.xyz/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="lijianchang.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to my blog</title>
    <link href="lijianchang.xyz/2016/03/12/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>lijianchang.xyz/2016/03/12/欢迎来到我的博客/</id>
    <published>2016-03-12T12:07:40.269Z</published>
    <updated>2016-05-12T03:26:27.371Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WelcomeToMyBlogback.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;博客刚刚搭建完成，很多东西都不懂，多多指教！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xrwkh.com1.z0.glb.clouddn.com/Post-WelcomeToMyBlogback.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="lijianchang.xyz/categories/life/"/>
    
    
      <category term="blog" scheme="lijianchang.xyz/tags/blog/"/>
    
  </entry>
  
</feed>
